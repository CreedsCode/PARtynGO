"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-js+accounts@0.1.4";
exports.ids = ["vendor-chunks/@near-js+accounts@0.1.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@0.0.5/node_modules/@near-js/crypto/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.0.7/node_modules/@near-js/providers/lib/index.js\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@0.2.1/node_modules/@near-js/transactions/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.0.4/node_modules/@near-js/utils/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\");\nconst { addKey, createAccount, deleteAccount, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey, stake, transfer, } = transactions_1.actionCreators;\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\nfunction parseJsonFromRawResponse(response) {\n    return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n    return Buffer.from(JSON.stringify(input));\n}\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link utils/key_pair!KeyPair}.\n *\n * @hint Use {@link walletAccount!WalletConnection} in the browser to redirect to [NEAR Wallet](https://wallet.near.org/) for Account/key management using the {@link key_stores/browser_local_storage_key_store!BrowserLocalStorageKeyStore}.\n * @see [https://docs.near.org/docs/develop/front-end/naj-quick-reference#account](https://docs.near.org/tools/near-api-js/quick-reference#account)\n * @see [Account Spec](https://nomicon.io/DataStructures/Account.html)\n */\nclass Account {\n    constructor(connection, accountId) {\n        /** @hidden */\n        this.accessKeyByPublicKeyCache = {};\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    /**\n     * Returns basic NEAR account information via the `view_account` RPC query method\n     * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)\n     */\n    state() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.connection.provider.query({\n                request_type: 'view_account',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n        });\n    }\n    /**\n     * Create a signed transaction which can be broadcast to the network\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions list of actions to perform as part of the transaction\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signTransaction(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeyInfo = yield this.findAccessKey(receiverId, actions);\n            if (!accessKeyInfo) {\n                throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, 'KeyNotFound');\n            }\n            const { accessKey } = accessKeyInfo;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const nonce = accessKey.nonce.add(new bn_js_1.default(1));\n            return yield (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, borsh_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n        });\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signAndSendTransaction({ receiverId, actions, returnError }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let txHash, signedTx;\n            // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n            const result = yield (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, () => __awaiter(this, void 0, void 0, function* () {\n                [txHash, signedTx] = yield this.signTransaction(receiverId, actions);\n                const publicKey = signedTx.transaction.publicKey;\n                try {\n                    return yield this.connection.provider.sendTransaction(signedTx);\n                }\n                catch (error) {\n                    if (error.type === 'InvalidNonce') {\n                        (0, utils_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} with new nonce.`);\n                        delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n                        return null;\n                    }\n                    if (error.type === 'Expired') {\n                        (0, utils_1.logWarning)(`Retrying transaction ${receiverId}:${(0, borsh_1.baseEncode)(txHash)} due to expired block hash`);\n                        return null;\n                    }\n                    error.context = new types_1.ErrorContext((0, borsh_1.baseEncode)(txHash));\n                    throw error;\n                }\n            }));\n            if (!result) {\n                // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n                throw new types_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n            }\n            (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });\n            // Should be falsy if result.status.Failure is null\n            if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object' && result.status.Failure !== null) {\n                // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n                if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                    throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n                }\n                else {\n                    throw (0, utils_1.parseResultError)(result);\n                }\n            }\n            // TODO: if Tx is Unknown or Started.\n            return result;\n        });\n    }\n    /**\n     * Finds the {@link providers/provider!AccessKeyView} associated with the accounts {@link utils/key_pair!PublicKey} stored in the {@link key_stores/keystore!KeyStore}.\n     *\n     * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n     *\n     * @param receiverId currently unused (see todo)\n     * @param actions currently unused (see todo)\n     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    findAccessKey(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n            const publicKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            if (!publicKey) {\n                throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, 'PublicKeyNotFound');\n            }\n            const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n            if (cachedAccessKey !== undefined) {\n                return { publicKey, accessKey: cachedAccessKey };\n            }\n            try {\n                const rawAccessKey = yield this.connection.provider.query({\n                    request_type: 'view_access_key',\n                    account_id: this.accountId,\n                    public_key: publicKey.toString(),\n                    finality: 'optimistic'\n                });\n                // store nonce as BN to preserve precision on big number\n                const accessKey = Object.assign(Object.assign({}, rawAccessKey), { nonce: new bn_js_1.default(rawAccessKey.nonce) });\n                // this function can be called multiple times and retrieve the same access key\n                // this checks to see if the access key was already retrieved and cached while\n                // the above network call was in flight. To keep nonce values in line, we return\n                // the cached access key.\n                if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n                    return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };\n                }\n                this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n                return { publicKey, accessKey };\n            }\n            catch (e) {\n                if (e.type == 'AccessKeyDoesNotExist') {\n                    return null;\n                }\n                throw e;\n            }\n        });\n    }\n    /**\n     * Create a new account and deploy a contract to it\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add to the created contract account\n     * @param data The compiled contract code\n     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n     */\n    createAndDeployContract(contractId, publicKey, data, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = fullAccessKey();\n            yield this.signAndSendTransaction({\n                receiverId: contractId,\n                actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey), deployContract(data)]\n            });\n            const contractAccount = new Account(this.connection, contractId);\n            return contractAccount;\n        });\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     */\n    sendMoney(receiverId, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId,\n                actions: [transfer(amount)]\n            });\n        });\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     */\n    createAccount(newAccountId, publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = fullAccessKey();\n            return this.signAndSendTransaction({\n                receiverId: newAccountId,\n                actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     */\n    deleteAccount(beneficiaryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!process.env['NEAR_NO_LOGS']) {\n                console.log('Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.');\n            }\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deleteAccount(beneficiaryId)]\n            });\n        });\n    }\n    /**\n     * @param data The compiled contract code\n     */\n    deployContract(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deployContract(data)]\n            });\n        });\n    }\n    /** @hidden */\n    encodeJSContractArgs(contractId, method, args) {\n        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);\n    }\n    /**\n     * Execute function call\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.validateArgs(args);\n            let functionCallArgs;\n            if (jsContract) {\n                const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));\n                functionCallArgs = ['call_js_contract', encodedArgs, gas, attachedDeposit, null, true];\n            }\n            else {\n                const stringifyArg = stringify === undefined ? transactions_1.stringifyJsonOrBytes : stringify;\n                functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];\n            }\n            return this.signAndSendTransaction({\n                receiverId: jsContract ? this.connection.jsvmAccountId : contractId,\n                // eslint-disable-next-line prefer-spread\n                actions: [functionCall.apply(void 0, functionCallArgs)],\n                walletMeta,\n                walletCallbackUrl\n            });\n        });\n    }\n    /**\n     * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)\n     * @todo expand this API to support more options.\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     */\n    addKey(publicKey, contractId, methodNames, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!methodNames) {\n                methodNames = [];\n            }\n            if (!Array.isArray(methodNames)) {\n                methodNames = [methodNames];\n            }\n            let accessKey;\n            if (!contractId) {\n                accessKey = fullAccessKey();\n            }\n            else {\n                accessKey = functionCallAccessKey(contractId, methodNames, amount);\n            }\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    deleteKey(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deleteKey(crypto_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /**\n     * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)\n     *\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     */\n    stake(publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [stake(amount, crypto_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /**\n     * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance\n     *\n     * @param actions Actions to be included in the meta transaction\n     * @param blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction\n     * @param receiverId Receiver account of the meta transaction\n     */\n    signedDelegate({ actions, blockHeightTtl, receiverId, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { provider, signer } = this.connection;\n            const { header } = yield provider.block({ finality: 'final' });\n            const { accessKey, publicKey } = yield this.findAccessKey(null, null);\n            const delegateAction = (0, transactions_1.buildDelegateAction)({\n                actions,\n                maxBlockHeight: new bn_js_1.default(header.height).add(new bn_js_1.default(blockHeightTtl)),\n                nonce: new bn_js_1.default(accessKey.nonce).add(new bn_js_1.default(1)),\n                publicKey,\n                receiverId,\n                senderId: this.accountId,\n            });\n            const { signedDelegateAction } = yield (0, transactions_1.signDelegateAction)({\n                delegateAction,\n                signer: {\n                    sign: (message) => __awaiter(this, void 0, void 0, function* () {\n                        const { signature } = yield signer.signMessage(message, delegateAction.senderId, this.connection.networkId);\n                        return signature;\n                    }),\n                }\n            });\n            return signedDelegateAction;\n        });\n    }\n    /** @hidden */\n    validateArgs(args) {\n        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n        if (isUint8Array) {\n            return;\n        }\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new types_1.PositionalArgsError();\n        }\n    }\n    /**\n     * Invoke a contract view function using the RPC API.\n     * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)\n     *\n     * @param viewFunctionCallOptions.contractId NEAR account where the contract is deployed\n     * @param viewFunctionCallOptions.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param viewFunctionCallOptions.args Any arguments to the view contract method, wrapped in JSON\n     * @param viewFunctionCallOptions.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n     * @param viewFunctionCallOptions.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n     * @param viewFunctionCallOptions.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.\n     * @param viewFunctionCallOptions.blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     * @returns {Promise<any>}\n     */\n    viewFunction({ contractId, methodName, args = {}, parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: 'optimistic' } }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let encodedArgs;\n            this.validateArgs(args);\n            if (jsContract) {\n                encodedArgs = this.encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : '');\n            }\n            else {\n                encodedArgs = stringify(args);\n            }\n            const result = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'call_function' }, blockQuery), { account_id: jsContract ? this.connection.jsvmAccountId : contractId, method_name: jsContract ? 'view_js_contract' : methodName, args_base64: encodedArgs.toString('base64') }));\n            if (result.logs) {\n                (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });\n            }\n            return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n        });\n    }\n    /**\n     * Returns the state (key value pairs) of this account's contract based on the key prefix.\n     * Pass an empty string for prefix if you would like to return the entire state.\n     * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)\n     *\n     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n     * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     */\n    viewState(prefix, blockQuery = { finality: 'optimistic' }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { values } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'view_state' }, blockQuery), { account_id: this.accountId, prefix_base64: Buffer.from(prefix).toString('base64') }));\n            return values.map(({ key, value }) => ({\n                key: Buffer.from(key, 'base64'),\n                value: Buffer.from(value, 'base64')\n            }));\n        });\n    }\n    /**\n     * Get all access keys for the account\n     * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)\n     */\n    getAccessKeys() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.connection.provider.query({\n                request_type: 'view_access_key_list',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n            // Replace raw nonce into a new BN\n            return (_a = response === null || response === void 0 ? void 0 : response.keys) === null || _a === void 0 ? void 0 : _a.map((key) => (Object.assign(Object.assign({}, key), { access_key: Object.assign(Object.assign({}, key.access_key), { nonce: new bn_js_1.default(key.access_key.nonce) }) })));\n        });\n    }\n    /**\n     * Returns a list of authorized apps\n     * @todo update the response value to return all the different keys, not just app keys.\n     */\n    getAccountDetails() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: update the response value to return all the different keys, not just app keys.\n            // Also if we need this function, or getAccessKeys is good enough.\n            const accessKeys = yield this.getAccessKeys();\n            const authorizedApps = accessKeys\n                .filter(item => item.access_key.permission !== 'FullAccess')\n                .map(item => {\n                const perm = item.access_key.permission;\n                return {\n                    contractId: perm.FunctionCall.receiver_id,\n                    amount: perm.FunctionCall.allowance,\n                    publicKey: item.public_key,\n                };\n            });\n            return { authorizedApps };\n        });\n    }\n    /**\n     * Returns calculated account balance\n     */\n    getAccountBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocolConfig = yield this.connection.provider.experimental_protocolConfig({ finality: 'final' });\n            const state = yield this.state();\n            const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);\n            const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n            const staked = new bn_js_1.default(state.locked);\n            const totalBalance = new bn_js_1.default(state.amount).add(staked);\n            const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));\n            return {\n                total: totalBalance.toString(),\n                stateStaked: stateStaked.toString(),\n                staked: staked.toString(),\n                available: availableBalance.toString()\n            };\n        });\n    }\n    /**\n     * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.\n     *\n     * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.\n     * @returns {Promise<ActiveDelegatedStakeBalance>}\n     */\n    getActiveDelegatedStakeBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const epochId = block.header.epoch_id;\n            const { current_validators, next_validators, current_proposals } = yield this.connection.provider.validators(epochId);\n            const pools = new Set();\n            [...current_validators, ...next_validators, ...current_proposals]\n                .forEach((validator) => pools.add(validator.account_id));\n            const uniquePools = [...pools];\n            const promises = uniquePools\n                .map((validator) => (this.viewFunction({\n                contractId: validator,\n                methodName: 'get_account_total_balance',\n                args: { account_id: this.accountId },\n                blockQuery: { blockId: blockHash }\n            })));\n            const results = yield Promise.allSettled(promises);\n            const hasTimeoutError = results.some((result) => {\n                if (result.status === 'rejected' && result.reason.type === 'TimeoutError') {\n                    return true;\n                }\n                return false;\n            });\n            // When RPC is down and return timeout error, throw error\n            if (hasTimeoutError) {\n                throw new Error('Failed to get delegated stake balance');\n            }\n            const summary = results.reduce((result, state, index) => {\n                const validatorId = uniquePools[index];\n                if (state.status === 'fulfilled') {\n                    const currentBN = new bn_js_1.default(state.value);\n                    if (!currentBN.isZero()) {\n                        return Object.assign(Object.assign({}, result), { stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }], total: result.total.add(currentBN) });\n                    }\n                }\n                if (state.status === 'rejected') {\n                    return Object.assign(Object.assign({}, result), { failedValidators: [...result.failedValidators, { validatorId, error: state.reason }] });\n                }\n                return result;\n            }, { stakedValidators: [], failedValidators: [], total: new bn_js_1.default(0) });\n            return Object.assign(Object.assign({}, summary), { total: summary.total.toString() });\n        });\n    }\n}\nexports.Account = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxtSEFBaUI7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQW9CO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLHFJQUF1QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBZ0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFPO0FBQy9CLFFBQVEsd0lBQXdJO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLDZCQUE2QjtBQUM1SDtBQUNBLGNBQWMsc0NBQXNDLDRHQUE0Ryw2RUFBNkU7QUFDN087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUM3STtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxXQUFXLEdBQUcsaUNBQWlDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFdBQVcsR0FBRyxpQ0FBaUM7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw4REFBOEQ7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsK0JBQStCLFVBQVUsb0NBQW9DO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0Isd0NBQXdDLDhCQUE4QixnQ0FBZ0MsZUFBZSxtQ0FBbUM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUIsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHVCQUF1QjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxnRUFBZ0UsbUJBQW1CLGdEQUFnRDtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQixpQ0FBaUMsa0hBQWtIO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsb0JBQW9CLFNBQVMseUJBQXlCLG1CQUFtQjtBQUN6RSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxtQkFBbUIsaUNBQWlDLHVHQUF1RywwQkFBMEI7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLCtCQUErQixpQkFBaUIsNktBQTZLO0FBQzNUO0FBQ0Esa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQSxvQkFBb0IsU0FBUyxxRUFBcUUsNEJBQTRCLGlCQUFpQixtRkFBbUY7QUFDbE8saUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0xBQWdMLFVBQVUsMENBQTBDLHFCQUFxQixrREFBa0QsR0FBRztBQUM5UyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csbUJBQW1CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBLG9CQUFvQix5REFBeUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsOEJBQThCO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWEsaURBQWlELDJDQUEyQyx1Q0FBdUM7QUFDN007QUFDQTtBQUNBO0FBQ0EseURBQXlELGFBQWEsaURBQWlELGtDQUFrQyxHQUFHO0FBQzVKO0FBQ0E7QUFDQSxhQUFhLElBQUksMkVBQTJFO0FBQzVGLGlEQUFpRCxjQUFjLGlDQUFpQztBQUNoRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDAuMS40L25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvYWNjb3VudC5qcz9mMmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnQgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9jcnlwdG9cIik7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy91dGlsc1wiKTtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGJvcnNoXzEgPSByZXF1aXJlKFwiYm9yc2hcIik7XG5jb25zdCB7IGFkZEtleSwgY3JlYXRlQWNjb3VudCwgZGVsZXRlQWNjb3VudCwgZGVsZXRlS2V5LCBkZXBsb3lDb250cmFjdCwgZnVsbEFjY2Vzc0tleSwgZnVuY3Rpb25DYWxsLCBmdW5jdGlvbkNhbGxBY2Nlc3NLZXksIHN0YWtlLCB0cmFuc2ZlciwgfSA9IHRyYW5zYWN0aW9uc18xLmFjdGlvbkNyZWF0b3JzO1xuLy8gRGVmYXVsdCBudW1iZXIgb2YgcmV0cmllcyB3aXRoIGRpZmZlcmVudCBub25jZSBiZWZvcmUgZ2l2aW5nIHVwIG9uIGEgdHJhbnNhY3Rpb24uXG5jb25zdCBUWF9OT05DRV9SRVRSWV9OVU1CRVIgPSAxMjtcbi8vIERlZmF1bHQgd2FpdCB1bnRpbCBuZXh0IHJldHJ5IGluIG1pbGxpcy5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX1dBSVQgPSA1MDA7XG4vLyBFeHBvbmVudGlhbCBiYWNrIG9mZiBmb3Igd2FpdGluZyB0byByZXRyeS5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX1dBSVRfQkFDS09GRiA9IDEuNTtcbmZ1bmN0aW9uIHBhcnNlSnNvbkZyb21SYXdSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHJlc3BvbnNlKS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzSnNvblN0cmluZ2lmeShpbnB1dCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGNvbW1vbiBhY2NvdW50IHJlbGF0ZWQgUlBDIGNhbGxzIGluY2x1ZGluZyBzaWduaW5nIHRyYW5zYWN0aW9ucyB3aXRoIGEge0BsaW5rIHV0aWxzL2tleV9wYWlyIUtleVBhaXJ9LlxuICpcbiAqIEBoaW50IFVzZSB7QGxpbmsgd2FsbGV0QWNjb3VudCFXYWxsZXRDb25uZWN0aW9ufSBpbiB0aGUgYnJvd3NlciB0byByZWRpcmVjdCB0byBbTkVBUiBXYWxsZXRdKGh0dHBzOi8vd2FsbGV0Lm5lYXIub3JnLykgZm9yIEFjY291bnQva2V5IG1hbmFnZW1lbnQgdXNpbmcgdGhlIHtAbGluayBrZXlfc3RvcmVzL2Jyb3dzZXJfbG9jYWxfc3RvcmFnZV9rZXlfc3RvcmUhQnJvd3NlckxvY2FsU3RvcmFnZUtleVN0b3JlfS5cbiAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9kb2NzL2RldmVsb3AvZnJvbnQtZW5kL25hai1xdWljay1yZWZlcmVuY2UjYWNjb3VudF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNhY2NvdW50KVxuICogQHNlZSBbQWNjb3VudCBTcGVjXShodHRwczovL25vbWljb24uaW8vRGF0YVN0cnVjdHVyZXMvQWNjb3VudC5odG1sKVxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuYWNjb3VudElkID0gYWNjb3VudElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJhc2ljIE5FQVIgYWNjb3VudCBpbmZvcm1hdGlvbiB2aWEgdGhlIGB2aWV3X2FjY291bnRgIFJQQyBxdWVyeSBtZXRob2RcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1hY2NvdW50XShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1hY2NvdW50KVxuICAgICAqL1xuICAgIHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNpZ25lZCB0cmFuc2FjdGlvbiB3aGljaCBjYW4gYmUgYnJvYWRjYXN0IHRvIHRoZSBuZXR3b3JrXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgTkVBUiBhY2NvdW50IHJlY2VpdmluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBsaXN0IG9mIGFjdGlvbnMgdG8gcGVyZm9ybSBhcyBwYXJ0IG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBzZWUge0BsaW5rIHByb3ZpZGVycy9qc29uLXJwYy1wcm92aWRlciFKc29uUnBjUHJvdmlkZXIjc2VuZFRyYW5zYWN0aW9uIHwgSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBzaWduVHJhbnNhY3Rpb24ocmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5SW5mbyA9IHlpZWxkIHRoaXMuZmluZEFjY2Vzc0tleShyZWNlaXZlcklkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgIGlmICghYWNjZXNzS2V5SW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoYENhbiBub3Qgc2lnbiB0cmFuc2FjdGlvbnMgZm9yIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCBubyBtYXRjaGluZyBrZXkgcGFpciBleGlzdHMgZm9yIHRoaXMgYWNjb3VudGAsICdLZXlOb3RGb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBhY2Nlc3NLZXkgfSA9IGFjY2Vzc0tleUluZm87XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGFjY2Vzc0tleS5ub25jZS5hZGQobmV3IGJuX2pzXzEuZGVmYXVsdCgxKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgKDAsIHRyYW5zYWN0aW9uc18xLnNpZ25UcmFuc2FjdGlvbikocmVjZWl2ZXJJZCwgbm9uY2UsIGFjdGlvbnMsICgwLCBib3JzaF8xLmJhc2VEZWNvZGUpKGJsb2NrSGFzaCksIHRoaXMuY29ubmVjdGlvbi5zaWduZXIsIHRoaXMuYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB0byBwcmVmb3JtIGEgbGlzdCBvZiBhY3Rpb25zIGFuZCBicm9hZGNhc3QgaXQgdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSB7QGxpbmsgcHJvdmlkZXJzL2pzb24tcnBjLXByb3ZpZGVyIUpzb25ScGNQcm92aWRlciNzZW5kVHJhbnNhY3Rpb24gfCBKc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zLCByZXR1cm5FcnJvciB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdHhIYXNoLCBzaWduZWRUeDtcbiAgICAgICAgICAgIC8vIFRPRE86IFRYX05PTkNFIChkaWZmZXJlbnQgY29uc3RhbnRzIGZvciBkaWZmZXJlbnQgdXNlcyBvZiBleHBvbmVudGlhbEJhY2tvZmY/KVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgKDAsIHByb3ZpZGVyc18xLmV4cG9uZW50aWFsQmFja29mZikoVFhfTk9OQ0VfUkVUUllfV0FJVCwgVFhfTk9OQ0VfUkVUUllfTlVNQkVSLCBUWF9OT05DRV9SRVRSWV9XQUlUX0JBQ0tPRkYsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBbdHhIYXNoLCBzaWduZWRUeF0gPSB5aWVsZCB0aGlzLnNpZ25UcmFuc2FjdGlvbihyZWNlaXZlcklkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduZWRUeC50cmFuc2FjdGlvbi5wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdJbnZhbGlkTm9uY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5sb2dXYXJuaW5nKShgUmV0cnlpbmcgdHJhbnNhY3Rpb24gJHtyZWNlaXZlcklkfTokeygwLCBib3JzaF8xLmJhc2VFbmNvZGUpKHR4SGFzaCl9IHdpdGggbmV3IG5vbmNlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ0V4cGlyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5sb2dXYXJuaW5nKShgUmV0cnlpbmcgdHJhbnNhY3Rpb24gJHtyZWNlaXZlcklkfTokeygwLCBib3JzaF8xLmJhc2VFbmNvZGUpKHR4SGFzaCl9IGR1ZSB0byBleHBpcmVkIGJsb2NrIGhhc2hgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNvbnRleHQgPSBuZXcgdHlwZXNfMS5FcnJvckNvbnRleHQoKDAsIGJvcnNoXzEuYmFzZUVuY29kZSkodHhIYXNoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgaGF2ZSBkaWZmZXJlbnQgY29kZSBhY3R1YWxseSwgYXMgbWVhbnMgXCJ0cmFuc2FjdGlvbiBub3Qgc3VibWl0dGVkIGZvciBzdXJlXCJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKCdub25jZSByZXRyaWVzIGV4Y2VlZGVkIGZvciB0cmFuc2FjdGlvbi4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZXJlIGFyZSB0b28gbWFueSBwYXJhbGxlbCByZXF1ZXN0cyB3aXRoIHRoZSBzYW1lIGFjY2VzcyBrZXkuJywgJ1JldHJpZXNFeGNlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIHV0aWxzXzEucHJpbnRUeE91dGNvbWVMb2dzQW5kRmFpbHVyZXMpKHsgY29udHJhY3RJZDogc2lnbmVkVHgudHJhbnNhY3Rpb24ucmVjZWl2ZXJJZCwgb3V0Y29tZTogcmVzdWx0IH0pO1xuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGZhbHN5IGlmIHJlc3VsdC5zdGF0dXMuRmFpbHVyZSBpcyBudWxsXG4gICAgICAgICAgICBpZiAoIXJldHVybkVycm9yICYmIHR5cGVvZiByZXN1bHQuc3RhdHVzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVzdWx0LnN0YXR1cy5GYWlsdXJlID09PSAnb2JqZWN0JyAmJiByZXN1bHQuc3RhdHVzLkZhaWx1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBlcnJvciBkYXRhIGhhcyBlcnJvcl9tZXNzYWdlIGFuZCBlcnJvcl90eXBlIHByb3BlcnRpZXMsIHdlIGNvbnNpZGVyIHRoYXQgbm9kZSByZXR1cm5lZCBhbiBlcnJvciBpbiB0aGUgb2xkIGZvcm1hdFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLkZhaWx1cmUuZXJyb3JfbWVzc2FnZSAmJiByZXN1bHQuc3RhdHVzLkZhaWx1cmUuZXJyb3JfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBUcmFuc2FjdGlvbiAke3Jlc3VsdC50cmFuc2FjdGlvbl9vdXRjb21lLmlkfSBmYWlsZWQuICR7cmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX21lc3NhZ2V9YCwgcmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX3R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucGFyc2VSZXN1bHRFcnJvcikocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBUeCBpcyBVbmtub3duIG9yIFN0YXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHtAbGluayBwcm92aWRlcnMvcHJvdmlkZXIhQWNjZXNzS2V5Vmlld30gYXNzb2NpYXRlZCB3aXRoIHRoZSBhY2NvdW50cyB7QGxpbmsgdXRpbHMva2V5X3BhaXIhUHVibGljS2V5fSBzdG9yZWQgaW4gdGhlIHtAbGluayBrZXlfc3RvcmVzL2tleXN0b3JlIUtleVN0b3JlfS5cbiAgICAgKlxuICAgICAqIEB0b2RvIEZpbmQgbWF0Y2hpbmcgYWNjZXNzIGtleSBiYXNlZCBvbiB0cmFuc2FjdGlvbiAoaS5lLiByZWNlaXZlcklkIGFuZCBhY3Rpb25zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgY3VycmVudGx5IHVudXNlZCAoc2VlIHRvZG8pXG4gICAgICogQHBhcmFtIGFjdGlvbnMgY3VycmVudGx5IHVudXNlZCAoc2VlIHRvZG8pXG4gICAgICogQHJldHVybnMgYHsgcHVibGljS2V5IFB1YmxpY0tleTsgYWNjZXNzS2V5OiBBY2Nlc3NLZXlWaWV3IH1gXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGZpbmRBY2Nlc3NLZXkocmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogRmluZCBtYXRjaGluZyBhY2Nlc3Mga2V5IGJhc2VkIG9uIHRyYW5zYWN0aW9uIChpLmUuIHJlY2VpdmVySWQgYW5kIGFjdGlvbnMpXG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLmdldFB1YmxpY0tleSh0aGlzLmFjY291bnRJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgICAgICAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoYG5vIG1hdGNoaW5nIGtleSBwYWlyIGZvdW5kIGluICR7dGhpcy5jb25uZWN0aW9uLnNpZ25lcn1gLCAnUHVibGljS2V5Tm90Rm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZEFjY2Vzc0tleSA9IHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkQWNjZXNzS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleTogY2FjaGVkQWNjZXNzS2V5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0FjY2Vzc0tleSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjZXNzX2tleScsXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpdHk6ICdvcHRpbWlzdGljJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG5vbmNlIGFzIEJOIHRvIHByZXNlcnZlIHByZWNpc2lvbiBvbiBiaWcgbnVtYmVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdBY2Nlc3NLZXkpLCB7IG5vbmNlOiBuZXcgYm5fanNfMS5kZWZhdWx0KHJhd0FjY2Vzc0tleS5ub25jZSkgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGFuZCByZXRyaWV2ZSB0aGUgc2FtZSBhY2Nlc3Mga2V5XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBhY2Nlc3Mga2V5IHdhcyBhbHJlYWR5IHJldHJpZXZlZCBhbmQgY2FjaGVkIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFib3ZlIG5ldHdvcmsgY2FsbCB3YXMgaW4gZmxpZ2h0LiBUbyBrZWVwIG5vbmNlIHZhbHVlcyBpbiBsaW5lLCB3ZSByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FjaGVkIGFjY2VzcyBrZXkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5LCBhY2Nlc3NLZXk6IHRoaXMuYWNjZXNzS2V5QnlQdWJsaWNLZXlDYWNoZVtwdWJsaWNLZXkudG9TdHJpbmcoKV0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSA9IGFjY2Vzc0tleTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09ICdBY2Nlc3NLZXlEb2VzTm90RXhpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY291bnQgYW5kIGRlcGxveSBhIGNvbnRyYWN0IHRvIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgY29udHJhY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb21waWxlZCBjb250cmFjdCBjb2RlXG4gICAgICogQHBhcmFtIGFtb3VudCBvZiBORUFSIHRvIHRyYW5zZmVyIHRvIHRoZSBjcmVhdGVkIGNvbnRyYWN0IGFjY291bnQuIFRyYW5zZmVyIGVub3VnaCB0byBwYXkgZm9yIHN0b3JhZ2UgaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2RvY3MvY29uY2VwdHMvc3RvcmFnZS1zdGFraW5nXG4gICAgICovXG4gICAgY3JlYXRlQW5kRGVwbG95Q29udHJhY3QoY29udHJhY3RJZCwgcHVibGljS2V5LCBkYXRhLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IGZ1bGxBY2Nlc3NLZXkoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogY29udHJhY3RJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbY3JlYXRlQWNjb3VudCgpLCB0cmFuc2ZlcihhbW91bnQpLCBhZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KSwgZGVwbG95Q29udHJhY3QoZGF0YSldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0QWNjb3VudCA9IG5ldyBBY2NvdW50KHRoaXMuY29ubmVjdGlvbiwgY29udHJhY3RJZCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RBY2NvdW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgTkVBUiBhY2NvdW50IHJlY2VpdmluZyDik4NcbiAgICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCB0byBzZW5kIGluIHlvY3Rv4pODXG4gICAgICovXG4gICAgc2VuZE1vbmV5KHJlY2VpdmVySWQsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbdHJhbnNmZXIoYW1vdW50KV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBORUFSIGFjY291bnQgbmFtZSB0byBiZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBBIHB1YmxpYyBrZXkgY3JlYXRlZCBmcm9tIHRoZSBtYXN0ZXJBY2NvdW50XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXkgPSBmdWxsQWNjZXNzS2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBuZXdBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW2NyZWF0ZUFjY291bnQoKSwgdHJhbnNmZXIoYW1vdW50KSwgYWRkS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSksIGFjY2Vzc0tleSldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBiZW5lZmljaWFyeUlkIFRoZSBORUFSIGFjY291bnQgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIHJlbWFpbmluZyDik4MgYmFsYW5jZSBmcm9tIHRoZSBhY2NvdW50IGJlaW5nIGRlbGV0ZWRcbiAgICAgKi9cbiAgICBkZWxldGVBY2NvdW50KGJlbmVmaWNpYXJ5SWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghcHJvY2Vzcy5lbnZbJ05FQVJfTk9fTE9HUyddKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0RlbGV0aW5nIGFuIGFjY291bnQgZG9lcyBub3QgYXV0b21hdGljYWxseSB0cmFuc2ZlciBORlRzIGFuZCBGVHMgdG8gdGhlIGJlbmVmaWNpYXJ5IGFkZHJlc3MuIEVuc3VyZSB0byB0cmFuc2ZlciBhc3NldHMgYmVmb3JlIGRlbGV0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW2RlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb21waWxlZCBjb250cmFjdCBjb2RlXG4gICAgICovXG4gICAgZGVwbG95Q29udHJhY3QoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW2RlcGxveUNvbnRyYWN0KGRhdGEpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGVuY29kZUpTQ29udHJhY3RBcmdzKGNvbnRyYWN0SWQsIG1ldGhvZCwgYXJncykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oY29udHJhY3RJZCksIEJ1ZmZlci5mcm9tKFswXSksIEJ1ZmZlci5mcm9tKG1ldGhvZCksIEJ1ZmZlci5mcm9tKFswXSksIEJ1ZmZlci5mcm9tKGFyZ3MpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgZnVuY3Rpb24gY2FsbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59XG4gICAgICovXG4gICAgZnVuY3Rpb25DYWxsKHsgY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncyA9IHt9LCBnYXMgPSB1dGlsc18xLkRFRkFVTFRfRlVOQ1RJT05fQ0FMTF9HQVMsIGF0dGFjaGVkRGVwb3NpdCwgd2FsbGV0TWV0YSwgd2FsbGV0Q2FsbGJhY2tVcmwsIHN0cmluZ2lmeSwganNDb250cmFjdCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvbkNhbGxBcmdzO1xuICAgICAgICAgICAgaWYgKGpzQ29udHJhY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkQXJncyA9IHRoaXMuZW5jb2RlSlNDb250cmFjdEFyZ3MoY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbEFyZ3MgPSBbJ2NhbGxfanNfY29udHJhY3QnLCBlbmNvZGVkQXJncywgZ2FzLCBhdHRhY2hlZERlcG9zaXQsIG51bGwsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZ5QXJnID0gc3RyaW5naWZ5ID09PSB1bmRlZmluZWQgPyB0cmFuc2FjdGlvbnNfMS5zdHJpbmdpZnlKc29uT3JCeXRlcyA6IHN0cmluZ2lmeTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxBcmdzID0gW21ldGhvZE5hbWUsIGFyZ3MsIGdhcywgYXR0YWNoZWREZXBvc2l0LCBzdHJpbmdpZnlBcmcsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IGpzQ29udHJhY3QgPyB0aGlzLmNvbm5lY3Rpb24uanN2bUFjY291bnRJZCA6IGNvbnRyYWN0SWQsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbZnVuY3Rpb25DYWxsLmFwcGx5KHZvaWQgMCwgZnVuY3Rpb25DYWxsQXJncyldLFxuICAgICAgICAgICAgICAgIHdhbGxldE1ldGEsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5c10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5cylcbiAgICAgKiBAdG9kbyBleHBhbmQgdGhpcyBBUEkgdG8gc3VwcG9ydCBtb3JlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBBIHB1YmxpYyBrZXkgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBjb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gbWV0aG9kTmFtZXMgVGhlIG1ldGhvZCBuYW1lcyBvbiB0aGUgY29udHJhY3QgdGhhdCBzaG91bGQgYmUgYWxsb3dlZCB0byBiZSBjYWxsZWQuIFBhc3MgbnVsbCBmb3Igbm8gbWV0aG9kIG5hbWVzIGFuZCAnJyBvciBbXSBmb3IgYW55IG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcGFyYW0gYW1vdW50IFBheW1lbnQgaW4geW9jdG/ik4MgdGhhdCBpcyBzZW50IHRvIHRoZSBjb250cmFjdCBkdXJpbmcgdGhpcyBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgYWRkS2V5KHB1YmxpY0tleSwgY29udHJhY3RJZCwgbWV0aG9kTmFtZXMsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kTmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSBbbWV0aG9kTmFtZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFjY2Vzc0tleTtcbiAgICAgICAgICAgIGlmICghY29udHJhY3RJZCkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9IGZ1bGxBY2Nlc3NLZXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9IGZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShjb250cmFjdElkLCBtZXRob2ROYW1lcywgYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFthZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBiZSBkZWxldGVkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmluYWxFeGVjdXRpb25PdXRjb21lPn1cbiAgICAgKi9cbiAgICBkZWxldGVLZXkocHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbZGVsZXRlS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIFtodHRwczovL25lYXItbm9kZXMuaW8vdmFsaWRhdG9yL3N0YWtpbmctYW5kLWRlbGVnYXRpb25dKGh0dHBzOi8vbmVhci1ub2Rlcy5pby92YWxpZGF0b3Ivc3Rha2luZy1hbmQtZGVsZWdhdGlvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBhY2NvdW50IHRoYXQncyBzdGFraW5nXG4gICAgICogQHBhcmFtIGFtb3VudCBUaGUgYWNjb3VudCB0byBzdGFrZSBpbiB5b2N0b+KTg1xuICAgICAqL1xuICAgIHN0YWtlKHB1YmxpY0tleSwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbc3Rha2UoYW1vdW50LCBjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSBhbmQgc2lnbiBhIFNpZ25lZERlbGVnYXRlIGFjdGlvbiB0byBiZSBleGVjdXRlZCBpbiBhIHRyYW5zYWN0aW9uIG9uIGJlaGFsZiBvZiB0aGlzIEFjY291bnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25zIEFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYmxvY2tIZWlnaHRUdGwgTnVtYmVyIG9mIGJsb2NrcyBwYXN0IHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodCBmb3Igd2hpY2ggdGhlIFNpZ25lZERlbGVnYXRlIGFjdGlvbiBtYXkgYmUgaW5jbHVkZWQgaW4gYSBtZXRhIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgUmVjZWl2ZXIgYWNjb3VudCBvZiB0aGUgbWV0YSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHNpZ25lZERlbGVnYXRlKHsgYWN0aW9ucywgYmxvY2tIZWlnaHRUdGwsIHJlY2VpdmVySWQsIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIHNpZ25lciB9ID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgeyBoZWFkZXIgfSA9IHlpZWxkIHByb3ZpZGVyLmJsb2NrKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY2Vzc0tleSwgcHVibGljS2V5IH0gPSB5aWVsZCB0aGlzLmZpbmRBY2Nlc3NLZXkobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkZWxlZ2F0ZUFjdGlvbiA9ICgwLCB0cmFuc2FjdGlvbnNfMS5idWlsZERlbGVnYXRlQWN0aW9uKSh7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgICAgICBtYXhCbG9ja0hlaWdodDogbmV3IGJuX2pzXzEuZGVmYXVsdChoZWFkZXIuaGVpZ2h0KS5hZGQobmV3IGJuX2pzXzEuZGVmYXVsdChibG9ja0hlaWdodFR0bCkpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBuZXcgYm5fanNfMS5kZWZhdWx0KGFjY2Vzc0tleS5ub25jZSkuYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoMSkpLFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkLFxuICAgICAgICAgICAgICAgIHNlbmRlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBzaWduZWREZWxlZ2F0ZUFjdGlvbiB9ID0geWllbGQgKDAsIHRyYW5zYWN0aW9uc18xLnNpZ25EZWxlZ2F0ZUFjdGlvbikoe1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlQWN0aW9uLFxuICAgICAgICAgICAgICAgIHNpZ25lcjoge1xuICAgICAgICAgICAgICAgICAgICBzaWduOiAobWVzc2FnZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IHlpZWxkIHNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlLCBkZWxlZ2F0ZUFjdGlvbi5zZW5kZXJJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzaWduZWREZWxlZ2F0ZUFjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgdmFsaWRhdGVBcmdzKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaXNVaW50OEFycmF5ID0gYXJncy5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJncy5ieXRlTGVuZ3RoID09PSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpIHx8IHR5cGVvZiBhcmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuUG9zaXRpb25hbEFyZ3NFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBhIGNvbnRyYWN0IHZpZXcgZnVuY3Rpb24gdXNpbmcgdGhlIFJQQyBBUEkuXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI2NhbGwtYS1jb250cmFjdC1mdW5jdGlvbl0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI2NhbGwtYS1jb250cmFjdC1mdW5jdGlvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3RnVuY3Rpb25DYWxsT3B0aW9ucy5jb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gdmlld0Z1bmN0aW9uQ2FsbE9wdGlvbnMubWV0aG9kTmFtZSBUaGUgdmlldy1vbmx5IG1ldGhvZCAobm8gc3RhdGUgbXV0YXRpb25zKSBuYW1lIG9uIHRoZSBjb250cmFjdCBhcyBpdCBpcyB3cml0dGVuIGluIHRoZSBjb250cmFjdCBjb2RlXG4gICAgICogQHBhcmFtIHZpZXdGdW5jdGlvbkNhbGxPcHRpb25zLmFyZ3MgQW55IGFyZ3VtZW50cyB0byB0aGUgdmlldyBjb250cmFjdCBtZXRob2QsIHdyYXBwZWQgaW4gSlNPTlxuICAgICAqIEBwYXJhbSB2aWV3RnVuY3Rpb25DYWxsT3B0aW9ucy5wYXJzZSBQYXJzZSB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsLiBSZWNlaXZlcyBhIEJ1ZmZlciAoYnl0ZXMgYXJyYXkpIGFuZCBjb252ZXJ0cyBpdCB0byBhbnkgb2JqZWN0LiBCeSBkZWZhdWx0IHJlc3VsdCB3aWxsIGJlIHRyZWF0ZWQgYXMganNvbi5cbiAgICAgKiBAcGFyYW0gdmlld0Z1bmN0aW9uQ2FsbE9wdGlvbnMuc3RyaW5naWZ5IENvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYSBieXRlcyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgaW5wdXQgaXMgdHJlYXRlZCBhcyBhIEpTT04uXG4gICAgICogQHBhcmFtIHZpZXdGdW5jdGlvbkNhbGxPcHRpb25zLmpzQ29udHJhY3QgSXMgY29udHJhY3QgZnJvbSBKUyBTREssIGF1dG9tYXRpY2FsbHkgZW5jb2RlcyBhcmdzIGZyb20gSlMgU0RLIHRvIGJpbmFyeS5cbiAgICAgKiBAcGFyYW0gdmlld0Z1bmN0aW9uQ2FsbE9wdGlvbnMuYmxvY2tRdWVyeSBzcGVjaWZpZXMgd2hpY2ggYmxvY2sgdG8gcXVlcnkgc3RhdGUgYXQuIEJ5IGRlZmF1bHQgcmV0dXJucyBsYXN0IFwib3B0aW1pc3RpY1wiIGJsb2NrIChpLmUuIG5vdCBuZWNlc3NhcmlseSBmaW5hbGl6ZWQpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdmlld0Z1bmN0aW9uKHsgY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncyA9IHt9LCBwYXJzZSA9IHBhcnNlSnNvbkZyb21SYXdSZXNwb25zZSwgc3RyaW5naWZ5ID0gYnl0ZXNKc29uU3RyaW5naWZ5LCBqc0NvbnRyYWN0ID0gZmFsc2UsIGJsb2NrUXVlcnkgPSB7IGZpbmFsaXR5OiAnb3B0aW1pc3RpYycgfSB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZW5jb2RlZEFyZ3M7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICAgICAgICAgIGlmIChqc0NvbnRyYWN0KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlZEFyZ3MgPSB0aGlzLmVuY29kZUpTQ29udHJhY3RBcmdzKGNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShhcmdzKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuY29kZWRBcmdzID0gc3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHJlcXVlc3RfdHlwZTogJ2NhbGxfZnVuY3Rpb24nIH0sIGJsb2NrUXVlcnkpLCB7IGFjY291bnRfaWQ6IGpzQ29udHJhY3QgPyB0aGlzLmNvbm5lY3Rpb24uanN2bUFjY291bnRJZCA6IGNvbnRyYWN0SWQsIG1ldGhvZF9uYW1lOiBqc0NvbnRyYWN0ID8gJ3ZpZXdfanNfY29udHJhY3QnIDogbWV0aG9kTmFtZSwgYXJnc19iYXNlNjQ6IGVuY29kZWRBcmdzLnRvU3RyaW5nKCdiYXNlNjQnKSB9KSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxvZ3MpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5wcmludFR4T3V0Y29tZUxvZ3MpKHsgY29udHJhY3RJZCwgbG9nczogcmVzdWx0LmxvZ3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdCAmJiByZXN1bHQucmVzdWx0Lmxlbmd0aCA+IDAgJiYgcGFyc2UoQnVmZmVyLmZyb20ocmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgKGtleSB2YWx1ZSBwYWlycykgb2YgdGhpcyBhY2NvdW50J3MgY29udHJhY3QgYmFzZWQgb24gdGhlIGtleSBwcmVmaXguXG4gICAgICogUGFzcyBhbiBlbXB0eSBzdHJpbmcgZm9yIHByZWZpeCBpZiB5b3Ugd291bGQgbGlrZSB0byByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZS5cbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1jb250cmFjdC1zdGF0ZV0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI3ZpZXctY29udHJhY3Qtc3RhdGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IGFsbG93cyB0byBmaWx0ZXIgd2hpY2gga2V5cyBzaG91bGQgYmUgcmV0dXJuZWQuIEVtcHR5IHByZWZpeCBtZWFucyBhbGwga2V5cy4gU3RyaW5nIHByZWZpeCBpcyB1dGYtOCBlbmNvZGVkLlxuICAgICAqIEBwYXJhbSBibG9ja1F1ZXJ5IHNwZWNpZmllcyB3aGljaCBibG9jayB0byBxdWVyeSBzdGF0ZSBhdC4gQnkgZGVmYXVsdCByZXR1cm5zIGxhc3QgXCJvcHRpbWlzdGljXCIgYmxvY2sgKGkuZS4gbm90IG5lY2Vzc2FyaWx5IGZpbmFsaXplZCkuXG4gICAgICovXG4gICAgdmlld1N0YXRlKHByZWZpeCwgYmxvY2tRdWVyeSA9IHsgZmluYWxpdHk6ICdvcHRpbWlzdGljJyB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlcyB9ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHJlcXVlc3RfdHlwZTogJ3ZpZXdfc3RhdGUnIH0sIGJsb2NrUXVlcnkpLCB7IGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkLCBwcmVmaXhfYmFzZTY0OiBCdWZmZXIuZnJvbShwcmVmaXgpLnRvU3RyaW5nKCdiYXNlNjQnKSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCgoeyBrZXksIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBCdWZmZXIuZnJvbShrZXksICdiYXNlNjQnKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBhY2Nlc3Mga2V5cyBmb3IgdGhlIGFjY291bnRcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9hY2Nlc3Mta2V5cyN2aWV3LWFjY2Vzcy1rZXktbGlzdF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYWNjZXNzLWtleXMjdmlldy1hY2Nlc3Mta2V5LWxpc3QpXG4gICAgICovXG4gICAgZ2V0QWNjZXNzS2V5cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIucXVlcnkoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjZXNzX2tleV9saXN0JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgcmF3IG5vbmNlIGludG8gYSBuZXcgQk5cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uua2V5cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoa2V5KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBrZXkpLCB7IGFjY2Vzc19rZXk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwga2V5LmFjY2Vzc19rZXkpLCB7IG5vbmNlOiBuZXcgYm5fanNfMS5kZWZhdWx0KGtleS5hY2Nlc3Nfa2V5Lm5vbmNlKSB9KSB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXV0aG9yaXplZCBhcHBzXG4gICAgICogQHRvZG8gdXBkYXRlIHRoZSByZXNwb25zZSB2YWx1ZSB0byByZXR1cm4gYWxsIHRoZSBkaWZmZXJlbnQga2V5cywgbm90IGp1c3QgYXBwIGtleXMuXG4gICAgICovXG4gICAgZ2V0QWNjb3VudERldGFpbHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhlIHJlc3BvbnNlIHZhbHVlIHRvIHJldHVybiBhbGwgdGhlIGRpZmZlcmVudCBrZXlzLCBub3QganVzdCBhcHAga2V5cy5cbiAgICAgICAgICAgIC8vIEFsc28gaWYgd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLCBvciBnZXRBY2Nlc3NLZXlzIGlzIGdvb2QgZW5vdWdoLlxuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5cyA9IHlpZWxkIHRoaXMuZ2V0QWNjZXNzS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXplZEFwcHMgPSBhY2Nlc3NLZXlzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYWNjZXNzX2tleS5wZXJtaXNzaW9uICE9PSAnRnVsbEFjY2VzcycpXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJtID0gaXRlbS5hY2Nlc3Nfa2V5LnBlcm1pc3Npb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RJZDogcGVybS5GdW5jdGlvbkNhbGwucmVjZWl2ZXJfaWQsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogcGVybS5GdW5jdGlvbkNhbGwuYWxsb3dhbmNlLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IGl0ZW0ucHVibGljX2tleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBhdXRob3JpemVkQXBwcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYWxjdWxhdGVkIGFjY291bnQgYmFsYW5jZVxuICAgICAqL1xuICAgIGdldEFjY291bnRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25maWcgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuZXhwZXJpbWVudGFsX3Byb3RvY29sQ29uZmlnKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHlpZWxkIHRoaXMuc3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvc3RQZXJCeXRlID0gbmV3IGJuX2pzXzEuZGVmYXVsdChwcm90b2NvbENvbmZpZy5ydW50aW1lX2NvbmZpZy5zdG9yYWdlX2Ftb3VudF9wZXJfYnl0ZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZVN0YWtlZCA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUuc3RvcmFnZV91c2FnZSkubXVsKGNvc3RQZXJCeXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWtlZCA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUubG9ja2VkKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQmFsYW5jZSA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUuYW1vdW50KS5hZGQoc3Rha2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUJhbGFuY2UgPSB0b3RhbEJhbGFuY2Uuc3ViKGJuX2pzXzEuZGVmYXVsdC5tYXgoc3Rha2VkLCBzdGF0ZVN0YWtlZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxCYWxhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3RhdGVTdGFrZWQ6IHN0YXRlU3Rha2VkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3Rha2VkOiBzdGFrZWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGF2YWlsYWJsZUJhbGFuY2UudG9TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5FQVIgdG9rZW5zIGJhbGFuY2UgYW5kIHZhbGlkYXRvcnMgb2YgYSBnaXZlbiBhY2NvdW50IHRoYXQgaXMgZGVsZWdhdGVkIHRvIHRoZSBzdGFraW5nIHBvb2xzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHZhbGlkYXRvcnMgc2V0IGluIHRoZSBjdXJyZW50IGVwb2NoLlxuICAgICAqXG4gICAgICogTk9URTogSWYgdGhlIHRva2VucyBhcmUgZGVsZWdhdGVkIHRvIGEgc3Rha2luZyBwb29sIHRoYXQgaXMgY3VycmVudGx5IG9uIHBhdXNlIG9yIGRvZXMgbm90IGhhdmUgZW5vdWdoIHRva2VucyB0byBwYXJ0aWNpcGF0ZSBpbiB2YWxpZGF0aW9uLCB0aGV5IHdvbid0IGJlIGFjY291bnRlZCBmb3IuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aXZlRGVsZWdhdGVkU3Rha2VCYWxhbmNlPn1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVEZWxlZ2F0ZWRTdGFrZUJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgICAgICBjb25zdCBlcG9jaElkID0gYmxvY2suaGVhZGVyLmVwb2NoX2lkO1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50X3ZhbGlkYXRvcnMsIG5leHRfdmFsaWRhdG9ycywgY3VycmVudF9wcm9wb3NhbHMgfSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci52YWxpZGF0b3JzKGVwb2NoSWQpO1xuICAgICAgICAgICAgY29uc3QgcG9vbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBbLi4uY3VycmVudF92YWxpZGF0b3JzLCAuLi5uZXh0X3ZhbGlkYXRvcnMsIC4uLmN1cnJlbnRfcHJvcG9zYWxzXVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHBvb2xzLmFkZCh2YWxpZGF0b3IuYWNjb3VudF9pZCkpO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlUG9vbHMgPSBbLi4ucG9vbHNdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB1bmlxdWVQb29sc1xuICAgICAgICAgICAgICAgIC5tYXAoKHZhbGlkYXRvcikgPT4gKHRoaXMudmlld0Z1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICBjb250cmFjdElkOiB2YWxpZGF0b3IsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2dldF9hY2NvdW50X3RvdGFsX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHsgYWNjb3VudF9pZDogdGhpcy5hY2NvdW50SWQgfSxcbiAgICAgICAgICAgICAgICBibG9ja1F1ZXJ5OiB7IGJsb2NrSWQ6IGJsb2NrSGFzaCB9XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcyk7XG4gICAgICAgICAgICBjb25zdCBoYXNUaW1lb3V0RXJyb3IgPSByZXN1bHRzLnNvbWUoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnICYmIHJlc3VsdC5yZWFzb24udHlwZSA9PT0gJ1RpbWVvdXRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2hlbiBSUEMgaXMgZG93biBhbmQgcmV0dXJuIHRpbWVvdXQgZXJyb3IsIHRocm93IGVycm9yXG4gICAgICAgICAgICBpZiAoaGFzVGltZW91dEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGRlbGVnYXRlZCBzdGFrZSBiYWxhbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdW1tYXJ5ID0gcmVzdWx0cy5yZWR1Y2UoKHJlc3VsdCwgc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9ySWQgPSB1bmlxdWVQb29sc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJOID0gbmV3IGJuX2pzXzEuZGVmYXVsdChzdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudEJOLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IHN0YWtlZFZhbGlkYXRvcnM6IFsuLi5yZXN1bHQuc3Rha2VkVmFsaWRhdG9ycywgeyB2YWxpZGF0b3JJZCwgYW1vdW50OiBjdXJyZW50Qk4udG9TdHJpbmcoKSB9XSwgdG90YWw6IHJlc3VsdC50b3RhbC5hZGQoY3VycmVudEJOKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgZmFpbGVkVmFsaWRhdG9yczogWy4uLnJlc3VsdC5mYWlsZWRWYWxpZGF0b3JzLCB7IHZhbGlkYXRvcklkLCBlcnJvcjogc3RhdGUucmVhc29uIH1dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgeyBzdGFrZWRWYWxpZGF0b3JzOiBbXSwgZmFpbGVkVmFsaWRhdG9yczogW10sIHRvdGFsOiBuZXcgYm5fanNfMS5kZWZhdWx0KDApIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VtbWFyeSksIHsgdG90YWw6IHN1bW1hcnkudG90YWwudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_2fa.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_2fa.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account2FA = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@0.0.5/node_modules/@near-js/crypto/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.0.7/node_modules/@near-js/providers/lib/index.js\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@0.2.1/node_modules/@near-js/transactions/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst account_multisig_1 = __webpack_require__(/*! ./account_multisig */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_multisig.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js\");\nconst types_2 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js\");\nconst { addKey, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey } = transactions_1.actionCreators;\nclass Account2FA extends account_multisig_1.AccountMultisig {\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = 'https://helper.testnet.near.org';\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link providers/json-rpc-provider!JsonRpcProvider#sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n            // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n            yield this.sendCode();\n            const result = yield this.promptAndVerify();\n            if (this.onConfirmResult) {\n                yield this.onConfirmResult(result);\n            }\n            return result;\n        });\n    }\n    // default helpers for CH deployments of multisig\n    deployMultisig(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const seedOrLedgerKey = (yield this.getRecoveryMethods()).data\n                .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n                .map((rm) => rm.publicKey);\n            const fak2lak = (yield this.getAccessKeys())\n                .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n                .map((ak) => ak.public_key)\n                .map(toPK);\n            const confirmOnlyKey = toPK((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n            const actions = [\n                ...fak2lak.map((pk) => deleteKey(pk)),\n                ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),\n                addKey(confirmOnlyKey, functionCallAccessKey(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),\n                deployContract(contractBytes),\n            ];\n            const newFunctionCallActionBatch = actions.concat(functionCall('new', newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));\n            console.log('deploying multisig contract for', accountId);\n            const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);\n            switch (multisigStateStatus) {\n                case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);\n                case types_2.MultisigStateStatus.VALID_STATE:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);\n                case types_2.MultisigStateStatus.INVALID_STATE:\n                    throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n                default:\n                    throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n        });\n    }\n    disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupActions = [];\n            if (cleanupContractBytes) {\n                yield this.deleteAllRequests().catch(e => e);\n                cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);\n            }\n            const keyConversionActions = yield this.get2faDisableKeyConversionActions();\n            const actions = [\n                ...cleanupActions,\n                ...keyConversionActions,\n                deployContract(contractBytes)\n            ];\n            const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);\n            if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n                throw new types_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n            }\n            return this.signAndSendTransactionWithAccount(this.accountId, actions);\n        });\n    }\n    get2faDisableCleanupActions(cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentAccountState = yield this.viewState('').catch(error => {\n                const cause = error.cause && error.cause.name;\n                if (cause == 'NO_CONTRACT_CODE') {\n                    return [];\n                }\n                throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                    ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                    : error;\n            });\n            const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n            return currentAccountState.length ? [\n                deployContract(cleanupContractBytes),\n                functionCall('clean', { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, new bn_js_1.default('0'))\n            ] : [];\n        });\n    }\n    get2faDisableKeyConversionActions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const accessKeys = yield this.getAccessKeys();\n            const lak2fak = accessKeys\n                .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n                .filter(({ access_key }) => {\n                const perm = access_key.permission.FunctionCall;\n                return perm.receiver_id === accountId &&\n                    perm.method_names.length === 4 &&\n                    perm.method_names.includes('add_request_and_confirm');\n            });\n            const confirmOnlyKey = crypto_1.PublicKey.from((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            return [\n                deleteKey(confirmOnlyKey),\n                ...lak2fak.map(({ public_key }) => deleteKey(crypto_1.PublicKey.from(public_key))),\n                ...lak2fak.map(({ public_key }) => addKey(crypto_1.PublicKey.from(public_key), fullAccessKey()))\n            ];\n        });\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n     */\n    disable(contractBytes, cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();\n            if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {\n                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n            let deleteAllRequestsError;\n            yield this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n            const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n                if (e.type === 'ContractHasExistingState') {\n                    throw deleteAllRequestsError || e;\n                }\n                throw e;\n            });\n            const actions = [\n                ...cleanupActions,\n                ...(yield this.get2faDisableKeyConversionActions()),\n                deployContract(contractBytes),\n            ];\n            console.log('disabling 2fa for', this.accountId);\n            return yield this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions\n            });\n        });\n    }\n    sendCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const { requestId } = this.getRequest();\n            const method = yield this.get2faMethod();\n            yield this.postSignedJson('/2fa/send', {\n                accountId,\n                method,\n                requestId,\n            });\n            return requestId;\n        });\n    }\n    getCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n        });\n    }\n    promptAndVerify() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const method = yield this.get2faMethod();\n            const securityCode = yield this.getCode(method);\n            try {\n                const result = yield this.verifyCode(securityCode);\n                // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n                return result;\n            }\n            catch (e) {\n                console.warn('Error validating security code:', e);\n                if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                    return yield this.promptAndVerify();\n                }\n                throw e;\n            }\n        });\n    }\n    verifyCodeDefault(securityCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const request = this.getRequest();\n            if (!request) {\n                throw new Error('no request pending');\n            }\n            const { requestId } = request;\n            return yield this.postSignedJson('/2fa/verify', {\n                accountId,\n                securityCode,\n                requestId\n            });\n        });\n    }\n    getRecoveryMethods() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            return {\n                accountId,\n                data: yield this.postSignedJson('/account/recoveryMethods', { accountId })\n            };\n        });\n    }\n    get2faMethod() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { data } = yield this.getRecoveryMethods();\n            if (data && data.length) {\n                data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n            }\n            if (!data)\n                return null;\n            const { kind, detail } = data;\n            return { kind, detail };\n        });\n    }\n    signatureFor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockNumber = block.header.height.toString();\n            const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n            const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n            return { blockNumber, blockNumberSignature };\n        });\n    }\n    postSignedJson(path, body) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield (0, providers_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), (yield this.signatureFor()))));\n        });\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => crypto_1.PublicKey.from(pk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50XzJmYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCLG1CQUFPLENBQUMsbUhBQWlCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMscUlBQXVCO0FBQ3RELGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLHFJQUFvQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyx1SEFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywrR0FBUztBQUNqQyxRQUFRLHdGQUF3RjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0EsNkRBQTZELHFCQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEIsY0FBYztBQUNuRTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckcseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQ2hKO0FBQ0EseUZBQXlGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUNoSjtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQzVJO0FBQ0EsYUFBYTtBQUNiLHVFQUF1RSxLQUFLO0FBQzVFO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QywyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2R0FBNkcsV0FBVztBQUN4SDtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUMsa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLHFGQUFxRixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0EsOEVBQThFLFdBQVc7QUFDekY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsaUVBQWlFLG1CQUFtQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AwLjEuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2FjY291bnRfMmZhLmpzPzYyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudDJGQSA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBuZWFyLWpzL2NyeXB0b1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHlwZXNcIik7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBhY2NvdW50X211bHRpc2lnXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50X211bHRpc2lnXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB7IGFkZEtleSwgZGVsZXRlS2V5LCBkZXBsb3lDb250cmFjdCwgZnVsbEFjY2Vzc0tleSwgZnVuY3Rpb25DYWxsLCBmdW5jdGlvbkNhbGxBY2Nlc3NLZXkgfSA9IHRyYW5zYWN0aW9uc18xLmFjdGlvbkNyZWF0b3JzO1xuY2xhc3MgQWNjb3VudDJGQSBleHRlbmRzIGFjY291bnRfbXVsdGlzaWdfMS5BY2NvdW50TXVsdGlzaWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGFjY291bnRJZCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBhY2NvdW50SWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhlbHBlclVybCA9ICdodHRwczovL2hlbHBlci50ZXN0bmV0Lm5lYXIub3JnJztcbiAgICAgICAgdGhpcy5oZWxwZXJVcmwgPSBvcHRpb25zLmhlbHBlclVybCB8fCB0aGlzLmhlbHBlclVybDtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlO1xuICAgICAgICB0aGlzLnNlbmRDb2RlID0gb3B0aW9ucy5zZW5kQ29kZSB8fCB0aGlzLnNlbmRDb2RlRGVmYXVsdDtcbiAgICAgICAgdGhpcy5nZXRDb2RlID0gb3B0aW9ucy5nZXRDb2RlIHx8IHRoaXMuZ2V0Q29kZURlZmF1bHQ7XG4gICAgICAgIHRoaXMudmVyaWZ5Q29kZSA9IG9wdGlvbnMudmVyaWZ5Q29kZSB8fCB0aGlzLnZlcmlmeUNvZGVEZWZhdWx0O1xuICAgICAgICB0aGlzLm9uQ29uZmlybVJlc3VsdCA9IG9wdGlvbnMub25Db25maXJtUmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gdG8gcHJlZm9ybSBhIGxpc3Qgb2YgYWN0aW9ucyBhbmQgYnJvYWRjYXN0IGl0IHVzaW5nIHRoZSBSUEMgQVBJLlxuICAgICAqIEBzZWUge0BsaW5rIHByb3ZpZGVycy9qc29uLXJwYy1wcm92aWRlciFKc29uUnBjUHJvdmlkZXIjc2VuZFRyYW5zYWN0aW9uIHwgSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHsgcmVjZWl2ZXJJZCwgYWN0aW9ucyB9KSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywgeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIGZvbGxvd2luZyBvdmVycmlkZSBvblJlcXVlc3RSZXN1bHQgaW4gc3VwZXJjbGFzcyBpbnN0ZWFkIG9mIGRvaW5nIGN1c3RvbSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uP1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZW5kQ29kZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wcm9tcHRBbmRWZXJpZnkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ29uZmlybVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMub25Db25maXJtUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZGVmYXVsdCBoZWxwZXJzIGZvciBDSCBkZXBsb3ltZW50cyBvZiBtdWx0aXNpZ1xuICAgIGRlcGxveU11bHRpc2lnKGNvbnRyYWN0Qnl0ZXMpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQ6IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc2VlZE9yTGVkZ2VyS2V5ID0gKHlpZWxkIHRoaXMuZ2V0UmVjb3ZlcnlNZXRob2RzKCkpLmRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IGtpbmQsIHB1YmxpY0tleSB9KSA9PiAoa2luZCA9PT0gJ3BocmFzZScgfHwga2luZCA9PT0gJ2xlZGdlcicpICYmIHB1YmxpY0tleSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAubWFwKChybSkgPT4gcm0ucHVibGljS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGZhazJsYWsgPSAoeWllbGQgdGhpcy5nZXRBY2Nlc3NLZXlzKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBwdWJsaWNfa2V5LCBhY2Nlc3Nfa2V5OiB7IHBlcm1pc3Npb24gfSB9KSA9PiBwZXJtaXNzaW9uID09PSAnRnVsbEFjY2VzcycgJiYgIXNlZWRPckxlZGdlcktleS5pbmNsdWRlcyhwdWJsaWNfa2V5KSlcbiAgICAgICAgICAgICAgICAubWFwKChhaykgPT4gYWsucHVibGljX2tleSlcbiAgICAgICAgICAgICAgICAubWFwKHRvUEspO1xuICAgICAgICAgICAgY29uc3QgY29uZmlybU9ubHlLZXkgPSB0b1BLKCh5aWVsZCB0aGlzLnBvc3RTaWduZWRKc29uKCcvMmZhL2dldEFjY2Vzc0tleScsIHsgYWNjb3VudElkIH0pKS5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgbmV3QXJncyA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHsgJ251bV9jb25maXJtYXRpb25zJzogMiB9KSk7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgIC4uLmZhazJsYWsubWFwKChwaykgPT4gZGVsZXRlS2V5KHBrKSksXG4gICAgICAgICAgICAgICAgLi4uZmFrMmxhay5tYXAoKHBrKSA9PiBhZGRLZXkocGssIGZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShhY2NvdW50SWQsIGNvbnN0YW50c18xLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTLCBudWxsKSkpLFxuICAgICAgICAgICAgICAgIGFkZEtleShjb25maXJtT25seUtleSwgZnVuY3Rpb25DYWxsQWNjZXNzS2V5KGFjY291bnRJZCwgY29uc3RhbnRzXzEuTVVMVElTSUdfQ09ORklSTV9NRVRIT0RTLCBudWxsKSksXG4gICAgICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY29udHJhY3RCeXRlcyksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2ggPSBhY3Rpb25zLmNvbmNhdChmdW5jdGlvbkNhbGwoJ25ldycsIG5ld0FyZ3MsIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVCkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2RlcGxveWluZyBtdWx0aXNpZyBjb250cmFjdCBmb3InLCBhY2NvdW50SWQpO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZVN0YXR1czogbXVsdGlzaWdTdGF0ZVN0YXR1cyB9ID0geWllbGQgdGhpcy5jaGVja011bHRpc2lnQ29kZUFuZFN0YXRlU3RhdHVzKGNvbnRyYWN0Qnl0ZXMpO1xuICAgICAgICAgICAgc3dpdGNoIChtdWx0aXNpZ1N0YXRlU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudC5jYWxsKHRoaXMsIGFjY291bnRJZCwgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2gpO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudC5jYWxsKHRoaXMsIGFjY291bnRJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuSU5WQUxJRF9TVEFURTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgaGFzIGV4aXN0aW5nIHN0YXRlLmAsICdDb250cmFjdEhhc0V4aXN0aW5nU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBzdGF0ZSBjb3VsZCBub3QgYmUgdmVyaWZpZWQuYCwgJ0NvbnRyYWN0U3RhdGVVbmtub3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNhYmxlV2l0aEZBSyh7IGNvbnRyYWN0Qnl0ZXMsIGNsZWFudXBDb250cmFjdEJ5dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjbGVhbnVwQWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNsZWFudXBDb250cmFjdEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kZWxldGVBbGxSZXF1ZXN0cygpLmNhdGNoKGUgPT4gZSk7XG4gICAgICAgICAgICAgICAgY2xlYW51cEFjdGlvbnMgPSB5aWVsZCB0aGlzLmdldDJmYURpc2FibGVDbGVhbnVwQWN0aW9ucyhjbGVhbnVwQ29udHJhY3RCeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlDb252ZXJzaW9uQWN0aW9ucyA9IHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCk7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgIC4uLmNsZWFudXBBY3Rpb25zLFxuICAgICAgICAgICAgICAgIC4uLmtleUNvbnZlcnNpb25BY3Rpb25zLFxuICAgICAgICAgICAgICAgIGRlcGxveUNvbnRyYWN0KGNvbnRyYWN0Qnl0ZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5SW5mbyA9IHlpZWxkIHRoaXMuZmluZEFjY2Vzc0tleSh0aGlzLmFjY291bnRJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYWNjZXNzS2V5SW5mbyAmJiBhY2Nlc3NLZXlJbmZvLmFjY2Vzc0tleSAmJiBhY2Nlc3NLZXlJbmZvLmFjY2Vzc0tleS5wZXJtaXNzaW9uICE9PSAnRnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKCdObyBmdWxsIGFjY2VzcyBrZXkgZm91bmQgaW4ga2V5c3RvcmUuIFVuYWJsZSB0byBieXBhc3MgbXVsdGlzaWcnLCAnTm9GQUtGb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbldpdGhBY2NvdW50KHRoaXMuYWNjb3VudElkLCBhY3Rpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldDJmYURpc2FibGVDbGVhbnVwQWN0aW9ucyhjbGVhbnVwQ29udHJhY3RCeXRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFjY291bnRTdGF0ZSA9IHlpZWxkIHRoaXMudmlld1N0YXRlKCcnKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZSAmJiBlcnJvci5jYXVzZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChjYXVzZSA9PSAnTk9fQ09OVFJBQ1RfQ09ERScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBjYXVzZSA9PSAnVE9PX0xBUkdFX0NPTlRSQUNUX1NUQVRFJ1xuICAgICAgICAgICAgICAgICAgICA/IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoYENhbiBub3QgZGVwbG95IGEgY29udHJhY3QgdG8gYWNjb3VudCAke3RoaXMuYWNjb3VudElkfSBvbiBuZXR3b3JrICR7dGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZH0sIHRoZSBhY2NvdW50IGhhcyBleGlzdGluZyBzdGF0ZS5gLCAnQ29udHJhY3RIYXNFeGlzdGluZ1N0YXRlJylcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFjY291bnRTdGF0ZUtleXMgPSBjdXJyZW50QWNjb3VudFN0YXRlLm1hcCgoeyBrZXkgfSkgPT4ga2V5LnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEFjY291bnRTdGF0ZS5sZW5ndGggPyBbXG4gICAgICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY2xlYW51cENvbnRyYWN0Qnl0ZXMpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbCgnY2xlYW4nLCB7IGtleXM6IGN1cnJlbnRBY2NvdW50U3RhdGVLZXlzIH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgbmV3IGJuX2pzXzEuZGVmYXVsdCgnMCcpKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXlzID0geWllbGQgdGhpcy5nZXRBY2Nlc3NLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBsYWsyZmFrID0gYWNjZXNzS2V5c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgYWNjZXNzX2tleSB9KSA9PiBhY2Nlc3Nfa2V5LnBlcm1pc3Npb24gIT09ICdGdWxsQWNjZXNzJylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IGFjY2Vzc19rZXkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcm0gPSBhY2Nlc3Nfa2V5LnBlcm1pc3Npb24uRnVuY3Rpb25DYWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJtLnJlY2VpdmVyX2lkID09PSBhY2NvdW50SWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcGVybS5tZXRob2RfbmFtZXMubGVuZ3RoID09PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgIHBlcm0ubWV0aG9kX25hbWVzLmluY2x1ZGVzKCdhZGRfcmVxdWVzdF9hbmRfY29uZmlybScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25maXJtT25seUtleSA9IGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKCh5aWVsZCB0aGlzLnBvc3RTaWduZWRKc29uKCcvMmZhL2dldEFjY2Vzc0tleScsIHsgYWNjb3VudElkIH0pKS5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBkZWxldGVLZXkoY29uZmlybU9ubHlLZXkpLFxuICAgICAgICAgICAgICAgIC4uLmxhazJmYWsubWFwKCh7IHB1YmxpY19rZXkgfSkgPT4gZGVsZXRlS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY19rZXkpKSksXG4gICAgICAgICAgICAgICAgLi4ubGFrMmZhay5tYXAoKHsgcHVibGljX2tleSB9KSA9PiBhZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljX2tleSksIGZ1bGxBY2Nlc3NLZXkoKSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgTEFLcyBiYWNrIHRvIEZBS3MsIGNsZWFycyBzdGF0ZSBhbmQgZGVwbG95cyBhbiAnZW1wdHknIGNvbnRyYWN0IChjb250cmFjdEJ5dGVzIHBhcmFtKVxuICAgICAqIEBwYXJhbSBbY29udHJhY3RCeXRlc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25lYXIvbmVhci13YWxsZXQvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZnJvbnRlbmQvc3JjL3dhc20vbWFpbi53YXNtP3Jhdz10cnVlfVxuICAgICAqIEBwYXJhbSBbY2xlYW51cENvbnRyYWN0Qnl0ZXNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL2NvcmUtY29udHJhY3RzL2Jsb2IvbWFzdGVyL3N0YXRlLWNsZWFudXAvcmVzL3N0YXRlX2NsZWFudXAud2FzbT9yYXc9dHJ1ZX1cbiAgICAgKi9cbiAgICBkaXNhYmxlKGNvbnRyYWN0Qnl0ZXMsIGNsZWFudXBDb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlU3RhdHVzIH0gPSB5aWVsZCB0aGlzLmNoZWNrTXVsdGlzaWdDb2RlQW5kU3RhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVN0YXR1cyAhPT0gdHlwZXNfMi5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFICYmIHN0YXRlU3RhdHVzICE9PSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgc3RhdGUgY291bGQgbm90IGJlIHZlcmlmaWVkLmAsICdDb250cmFjdFN0YXRlVW5rbm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlbGV0ZUFsbFJlcXVlc3RzRXJyb3I7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZUFsbFJlcXVlc3RzKCkuY2F0Y2goZSA9PiBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yID0gZSk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwQWN0aW9ucyA9IHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnQ29udHJhY3RIYXNFeGlzdGluZ1N0YXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2xlYW51cEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uKHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCkpLFxuICAgICAgICAgICAgICAgIGRlcGxveUNvbnRyYWN0KGNvbnRyYWN0Qnl0ZXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkaXNhYmxpbmcgMmZhIGZvcicsIHRoaXMuYWNjb3VudElkKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZENvZGVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gdGhpcy5nZXRSZXF1ZXN0KCk7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSB5aWVsZCB0aGlzLmdldDJmYU1ldGhvZCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wb3N0U2lnbmVkSnNvbignLzJmYS9zZW5kJywge1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdElkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGdldENvZGUgY2FsbGJhY2sgcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIHlvdXIgb3duIGluIEFjY291bnRNdWx0aXNpZyBjb25zdHJ1Y3RvciBvcHRpb25zLiBJdCBoYXMgYSBwYXJhbWV0ZXIgbWV0aG9kIHdoZXJlIG1ldGhvZC5raW5kIGlzIFwiZW1haWxcIiBvciBcInBob25lXCIuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9tcHRBbmRWZXJpZnkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSB5aWVsZCB0aGlzLmdldDJmYU1ldGhvZCgpO1xuICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHlDb2RlID0geWllbGQgdGhpcy5nZXRDb2RlKG1ldGhvZCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMudmVyaWZ5Q29kZShzZWN1cml0eUNvZGUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFBhcnNlIGVycm9yIGZyb20gcmVzdWx0IGZvciByZWFsIChsaWtlIGluIG5vcm1hbCBhY2NvdW50LnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB2YWxpZGF0aW5nIHNlY3VyaXR5IGNvZGU6JywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmNsdWRlcygnaW52YWxpZCAyZmEgY29kZSBwcm92aWRlZCcpIHx8IGUudG9TdHJpbmcoKS5pbmNsdWRlcygnMmZhIGNvZGUgbm90IHZhbGlkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvbXB0QW5kVmVyaWZ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJpZnlDb2RlRGVmYXVsdChzZWN1cml0eUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UmVxdWVzdCgpO1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyByZXF1ZXN0IHBlbmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvdmVyaWZ5Jywge1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvZGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlY292ZXJ5TWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgZGF0YTogeWllbGQgdGhpcy5wb3N0U2lnbmVkSnNvbignL2FjY291bnQvcmVjb3ZlcnlNZXRob2RzJywgeyBhY2NvdW50SWQgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQyZmFNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgeyBkYXRhIH0gPSB5aWVsZCB0aGlzLmdldFJlY292ZXJ5TWV0aG9kcygpO1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5maW5kKChtKSA9PiBtLmtpbmQuaW5kZXhPZignMmZhLScpID09PSAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgZGV0YWlsIH0gPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHsga2luZCwgZGV0YWlsIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduYXR1cmVGb3IoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLmJsb2NrKHsgZmluYWxpdHk6ICdmaW5hbCcgfSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGJsb2NrLmhlYWRlci5oZWlnaHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5zaWduZXIuc2lnbk1lc3NhZ2UoQnVmZmVyLmZyb20oYmxvY2tOdW1iZXIpLCBhY2NvdW50SWQsIHRoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWQpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXJTaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduZWQuc2lnbmF0dXJlKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICByZXR1cm4geyBibG9ja051bWJlciwgYmxvY2tOdW1iZXJTaWduYXR1cmUgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc3RTaWduZWRKc29uKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgcHJvdmlkZXJzXzEuZmV0Y2hKc29uKSh0aGlzLmhlbHBlclVybCArIHBhdGgsIEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm9keSksICh5aWVsZCB0aGlzLnNpZ25hdHVyZUZvcigpKSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BY2NvdW50MkZBID0gQWNjb3VudDJGQTtcbi8vIGhlbHBlcnNcbmNvbnN0IHRvUEsgPSAocGspID0+IGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHBrKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_2fa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_creator.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_creator.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.0.7/node_modules/@near-js/providers/lib/index.js\");\n/**\n * Account creator provides an interface for implementations to actually create accounts\n */\nclass AccountCreator {\n}\nexports.AccountCreator = AccountCreator;\nclass LocalAccountCreator extends AccountCreator {\n    constructor(masterAccount, initialBalance) {\n        super();\n        this.masterAccount = masterAccount;\n        this.initialBalance = initialBalance;\n    }\n    /**\n     * Creates an account using a masterAccount, meaning the new account is created from an existing account\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);\n        });\n    }\n}\nexports.LocalAccountCreator = LocalAccountCreator;\nclass UrlAccountCreator extends AccountCreator {\n    constructor(connection, helperUrl) {\n        super();\n        this.connection = connection;\n        this.helperUrl = helperUrl;\n    }\n    /**\n     * Creates an account using a helperUrl\n     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield (0, providers_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));\n        });\n    }\n}\nexports.UrlAccountCreator = UrlAccountCreator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X2NyZWF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQjtBQUNoRixvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsNEJBQTRCLHlEQUF5RDtBQUNwSixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X2NyZWF0b3IuanM/OGViNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcmxBY2NvdW50Q3JlYXRvciA9IGV4cG9ydHMuTG9jYWxBY2NvdW50Q3JlYXRvciA9IGV4cG9ydHMuQWNjb3VudENyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG4vKipcbiAqIEFjY291bnQgY3JlYXRvciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGltcGxlbWVudGF0aW9ucyB0byBhY3R1YWxseSBjcmVhdGUgYWNjb3VudHNcbiAqL1xuY2xhc3MgQWNjb3VudENyZWF0b3Ige1xufVxuZXhwb3J0cy5BY2NvdW50Q3JlYXRvciA9IEFjY291bnRDcmVhdG9yO1xuY2xhc3MgTG9jYWxBY2NvdW50Q3JlYXRvciBleHRlbmRzIEFjY291bnRDcmVhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJBY2NvdW50LCBpbml0aWFsQmFsYW5jZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckFjY291bnQgPSBtYXN0ZXJBY2NvdW50O1xuICAgICAgICB0aGlzLmluaXRpYWxCYWxhbmNlID0gaW5pdGlhbEJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWNjb3VudCB1c2luZyBhIG1hc3RlckFjY291bnQsIG1lYW5pbmcgdGhlIG5ldyBhY2NvdW50IGlzIGNyZWF0ZWQgZnJvbSBhbiBleGlzdGluZyBhY2NvdW50XG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBUaGUgbmFtZSBvZiB0aGUgTkVBUiBhY2NvdW50IHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGZyb20gdGhlIG1hc3RlckFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhpcyBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5tYXN0ZXJBY2NvdW50LmNyZWF0ZUFjY291bnQobmV3QWNjb3VudElkLCBwdWJsaWNLZXksIHRoaXMuaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBMb2NhbEFjY291bnRDcmVhdG9yO1xuY2xhc3MgVXJsQWNjb3VudENyZWF0b3IgZXh0ZW5kcyBBY2NvdW50Q3JlYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgaGVscGVyVXJsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuaGVscGVyVXJsID0gaGVscGVyVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFjY291bnQgdXNpbmcgYSBoZWxwZXJVcmxcbiAgICAgKiBUaGlzIGlzIFtob3N0ZWQgaGVyZV0oaHR0cHM6Ly9oZWxwZXIubmVhcnByb3RvY29sLmNvbSkgb3Igc2V0IHVwIGxvY2FsbHkgd2l0aCB0aGUgW25lYXItY29udHJhY3QtaGVscGVyXShodHRwczovL2dpdGh1Yi5jb20vbmVhcnByb3RvY29sL25lYXItY29udHJhY3QtaGVscGVyKSByZXBvc2l0b3J5XG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBUaGUgbmFtZSBvZiB0aGUgTkVBUiBhY2NvdW50IHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGZyb20gdGhlIG1hc3RlckFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhpcyBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgKDAsIHByb3ZpZGVyc18xLmZldGNoSnNvbikoYCR7dGhpcy5oZWxwZXJVcmx9L2FjY291bnRgLCBKU09OLnN0cmluZ2lmeSh7IG5ld0FjY291bnRJZCwgbmV3QWNjb3VudFB1YmxpY0tleTogcHVibGljS2V5LnRvU3RyaW5nKCkgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlVybEFjY291bnRDcmVhdG9yID0gVXJsQWNjb3VudENyZWF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_creator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_multisig.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_multisig.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AccountMultisig = void 0;\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@0.2.1/node_modules/@near-js/transactions/lib/index.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js\");\nconst { deployContract, functionCall } = transactions_1.actionCreators;\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [constants_1.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    signAndSendTransactionWithAccount(receiverId, actions) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.signAndSendTransaction.call(this, { receiverId, actions });\n        });\n    }\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const args = Buffer.from(JSON.stringify({\n                request: {\n                    receiver_id: receiverId,\n                    actions: convertActions(actions, accountId, receiverId)\n                }\n            }));\n            let result;\n            try {\n                result = yield _super.signAndSendTransaction.call(this, {\n                    receiverId: accountId,\n                    actions: [\n                        functionCall('add_request_and_confirm', args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            catch (e) {\n                if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                    yield this.deleteUnconfirmedRequests();\n                    return yield this.signAndSendTransaction({ receiverId, actions });\n                }\n                throw e;\n            }\n            // TODO: Are following even needed? Seems like it throws on error already\n            if (!result.status) {\n                throw new Error('Request failed');\n            }\n            const status = Object.assign({}, result.status);\n            if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n                throw new Error('Request failed');\n            }\n            this.setRequest({\n                accountId,\n                actions,\n                requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n            });\n            if (this.onAddRequestResult) {\n                yield this.onAddRequestResult(result);\n            }\n            // NOTE there is no await on purpose to avoid blocking for 2fa\n            this.deleteUnconfirmedRequests();\n            return result;\n        });\n    }\n    /*\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     */\n    checkMultisigCodeAndStateStatus(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const u32_max = 4294967295;\n            const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n            try {\n                if (contractBytes) {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId, actions: [\n                            deployContract(contractBytes),\n                            functionCall('delete_request', { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                        ]\n                    });\n                }\n                else {\n                    yield this.deleteRequest(u32_max);\n                }\n                return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n            }\n            catch (e) {\n                if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                    // not reachable if transaction included a deploy\n                    return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };\n                }\n                throw e;\n            }\n        });\n    }\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [functionCall('delete_request', { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n        });\n    }\n    deleteAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request_ids = yield this.getRequestIds();\n            if (request_ids.length) {\n                yield Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n            }\n        });\n    }\n    deleteUnconfirmedRequests() {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Delete in batch, don't delete unexpired\n            // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n            const request_ids = yield this.getRequestIds();\n            const { requestId } = this.getRequest();\n            for (const requestIdToDelete of request_ids) {\n                if (requestIdToDelete == requestId) {\n                    continue;\n                }\n                try {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId,\n                        actions: [functionCall('delete_request', { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n                    });\n                }\n                catch (e) {\n                    console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n                }\n            }\n        });\n    }\n    // helpers\n    getRequestIds() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Read requests from state to allow filtering by expiration time\n            // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n            return this.viewFunction({\n                contractId: this.accountId,\n                methodName: 'list_request_ids',\n            });\n        });\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[constants_1.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: constants_1.MULTISIG_ALLOWANCE.toString(),\n                method_names: constants_1.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsdUJBQXVCLG1CQUFPLENBQUMscUlBQXVCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLG1IQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHVIQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLCtHQUFTO0FBQ2pDLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRixTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QscUJBQXFCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHFCQUFxQjtBQUNsRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLCtCQUErQjtBQUNsRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFnRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X211bHRpc2lnLmpzPzNmMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudE11bHRpc2lnID0gdm9pZCAwO1xuY29uc3QgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHJhbnNhY3Rpb25zXCIpO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgeyBkZXBsb3lDb250cmFjdCwgZnVuY3Rpb25DYWxsIH0gPSB0cmFuc2FjdGlvbnNfMS5hY3Rpb25DcmVhdG9ycztcbnZhciBNdWx0aXNpZ0NvZGVTdGF0dXM7XG4oZnVuY3Rpb24gKE11bHRpc2lnQ29kZVN0YXR1cykge1xuICAgIE11bHRpc2lnQ29kZVN0YXR1c1tNdWx0aXNpZ0NvZGVTdGF0dXNbXCJJTlZBTElEX0NPREVcIl0gPSAwXSA9IFwiSU5WQUxJRF9DT0RFXCI7XG4gICAgTXVsdGlzaWdDb2RlU3RhdHVzW011bHRpc2lnQ29kZVN0YXR1c1tcIlZBTElEX0NPREVcIl0gPSAxXSA9IFwiVkFMSURfQ09ERVwiO1xuICAgIE11bHRpc2lnQ29kZVN0YXR1c1tNdWx0aXNpZ0NvZGVTdGF0dXNbXCJVTktOT1dOX0NPREVcIl0gPSAyXSA9IFwiVU5LTk9XTl9DT0RFXCI7XG59KShNdWx0aXNpZ0NvZGVTdGF0dXMgfHwgKE11bHRpc2lnQ29kZVN0YXR1cyA9IHt9KSk7XG4vLyBpbiBtZW1vcnkgcmVxdWVzdCBjYWNoZSBmb3Igbm9kZSB3L28gbG9jYWxTdG9yYWdlXG5jb25zdCBzdG9yYWdlRmFsbGJhY2sgPSB7XG4gICAgW2NvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZXTogbnVsbFxufTtcbmNsYXNzIEFjY291bnRNdWx0aXNpZyBleHRlbmRzIGFjY291bnRfMS5BY2NvdW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBhY2NvdW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgYWNjb3VudElkKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlO1xuICAgICAgICB0aGlzLm9uQWRkUmVxdWVzdFJlc3VsdCA9IG9wdGlvbnMub25BZGRSZXF1ZXN0UmVzdWx0O1xuICAgIH1cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQocmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHsgcmVjZWl2ZXJJZCwgYWN0aW9ucyB9KSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkOiByZWNlaXZlcklkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBjb252ZXJ0QWN0aW9ucyhhY3Rpb25zLCBhY2NvdW50SWQsIHJlY2VpdmVySWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsKCdhZGRfcmVxdWVzdF9hbmRfY29uZmlybScsIGFyZ3MsIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVClcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLmluY2x1ZGVzKCdBY2NvdW50IGhhcyB0b28gbWFueSBhY3RpdmUgcmVxdWVzdHMuIENvbmZpcm0gb3IgZGVsZXRlIHNvbWUnKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBBcmUgZm9sbG93aW5nIGV2ZW4gbmVlZGVkPyBTZWVtcyBsaWtlIGl0IHRocm93cyBvbiBlcnJvciBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQuc3RhdHVzKTtcbiAgICAgICAgICAgIGlmICghc3RhdHVzLlN1Y2Nlc3NWYWx1ZSB8fCB0eXBlb2Ygc3RhdHVzLlN1Y2Nlc3NWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcGFyc2VJbnQoQnVmZmVyLmZyb20oc3RhdHVzLlN1Y2Nlc3NWYWx1ZSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpLCAxMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25BZGRSZXF1ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkFkZFJlcXVlc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEUgdGhlcmUgaXMgbm8gYXdhaXQgb24gcHVycG9zZSB0byBhdm9pZCBibG9ja2luZyBmb3IgMmZhXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVVuY29uZmlybWVkUmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRoaXMgbWV0aG9kIHN1Ym1pdHMgYSBjYW5hcnkgdHJhbnNhY3Rpb24gdGhhdCBpcyBleHBlY3RlZCB0byBhbHdheXMgZmFpbCBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgY29udHJhY3QgY3VycmVudGx5IGhhcyB2YWxpZCBtdWx0aXNpZyBzdGF0ZVxuICAgICAqIGFuZCB3aGV0aGVyIGl0IGlzIGluaXRpYWxpemVkLiBUaGUgY2FuYXJ5IHRyYW5zYWN0aW9uIGF0dGVtcHRzIHRvIGRlbGV0ZSBhIHJlcXVlc3QgYXQgaW5kZXggdTMyX21heCBhbmQgd2lsbCBnbyB0aHJvdWdoIGlmIGEgcmVxdWVzdCBleGlzdHMgYXQgdGhhdCBpbmRleC5cbiAgICAgKiBhIHUzMl9tYXggKyAxIGFuZCAtMSB2YWx1ZSBjYW5ub3QgYmUgdXNlZCBmb3IgdGhlIGNhbmFyeSBkdWUgdG8gZXhwZWN0ZWQgdTMyIGVycm9yIHRocm93biBiZWZvcmUgZGVzZXJpYWxpemF0aW9uIGF0dGVtcHQuXG4gICAgICovXG4gICAgY2hlY2tNdWx0aXNpZ0NvZGVBbmRTdGF0ZVN0YXR1cyhjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMl9tYXggPSA0Mjk0OTY3Mjk1O1xuICAgICAgICAgICAgY29uc3QgdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSA9IGNvbnRyYWN0Qnl0ZXMgPyBNdWx0aXNpZ0NvZGVTdGF0dXMuVU5LTk9XTl9DT0RFIDogTXVsdGlzaWdDb2RlU3RhdHVzLlZBTElEX0NPREU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBsb3lDb250cmFjdChjb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkOiB1MzJfbWF4IH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVClcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZVJlcXVlc3QodTMyX21heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvZGVTdGF0dXM6IE11bHRpc2lnQ29kZVN0YXR1cy5WQUxJRF9DT0RFLCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuQ0FOTk9UX0RFU0VSSUFMSVpFX1NUQVRFKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5JTlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldyBSZWdFeHAodHlwZXNfMS5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvci5NVUxUSVNJR19OT1RfSU5JVElBTElaRUQpLnRlc3QoZSAmJiBlLmtpbmQgJiYgZS5raW5kLkV4ZWN1dGlvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiB2YWxpZENvZGVTdGF0dXNJZk5vRGVwbG95LCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlNUQVRFX05PVF9JTklUSUFMSVpFRCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTk9fU1VDSF9SRVFVRVNUKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTUVUSE9EX05PVF9GT1VORCkudGVzdChlICYmIGUubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHJlYWNoYWJsZSBpZiB0cmFuc2FjdGlvbiBpbmNsdWRlZCBhIGRlcGxveVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiBNdWx0aXNpZ0NvZGVTdGF0dXMuSU5WQUxJRF9DT0RFLCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlVOS05PV05fU1RBVEUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZVJlcXVlc3QocmVxdWVzdF9pZCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtmdW5jdGlvbkNhbGwoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkIH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVCldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGVBbGxSZXF1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RfaWRzID0geWllbGQgdGhpcy5nZXRSZXF1ZXN0SWRzKCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdF9pZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocmVxdWVzdF9pZHMubWFwKChpZCkgPT4gdGhpcy5kZWxldGVSZXF1ZXN0KGlkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlVW5jb25maXJtZWRSZXF1ZXN0cygpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiB7IGdldDogKCkgPT4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIGluIGJhdGNoLCBkb24ndCBkZWxldGUgdW5leHBpcmVkXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgaW4gYmF0Y2gsIGRvbid0IGRlbGV0ZSB1bmV4cGlyZWQgKGNhbiByZWR1Y2UgZ2FzIHVzYWdlIGRyYW1hdGljYWxseSlcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RfaWRzID0geWllbGQgdGhpcy5nZXRSZXF1ZXN0SWRzKCk7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gdGhpcy5nZXRSZXF1ZXN0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RJZFRvRGVsZXRlIG9mIHJlcXVlc3RfaWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RJZFRvRGVsZXRlID09IHJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtmdW5jdGlvbkNhbGwoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkOiByZXF1ZXN0SWRUb0RlbGV0ZSB9LCBjb25zdGFudHNfMS5NVUxUSVNJR19HQVMsIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQpXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0IHRvIGRlbGV0ZSBhbiBlYXJsaWVyIHJlcXVlc3QgYmVmb3JlIDE1IG1pbnV0ZXMgZmFpbGVkLiBXaWxsIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBoZWxwZXJzXG4gICAgZ2V0UmVxdWVzdElkcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlYWQgcmVxdWVzdHMgZnJvbSBzdGF0ZSB0byBhbGxvdyBmaWx0ZXJpbmcgYnkgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAgICAgICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vbmVhci9jb3JlLWNvbnRyYWN0cy9ibG9iLzMwNWQxZGI0ZjRmMmNmNWNlNGMxZWYzNDc5Zjc1NDQ5NTczODFmMTEvbXVsdGlzaWcvc3JjL2xpYi5ycyNMODRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgY29udHJhY3RJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2xpc3RfcmVxdWVzdF9pZHMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWSkgfHwgJ3t9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2VGYWxsYmFja1tjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWV07XG4gICAgfVxuICAgIHNldFJlcXVlc3QoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0oY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlRmFsbGJhY2tbY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVldID0gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRNdWx0aXNpZyA9IEFjY291bnRNdWx0aXNpZztcbmNvbnN0IGNvbnZlcnRQS0ZvckNvbnRyYWN0ID0gKHBrKSA9PiBway50b1N0cmluZygpLnJlcGxhY2UoJ2VkMjU1MTk6JywgJycpO1xuY29uc3QgY29udmVydEFjdGlvbnMgPSAoYWN0aW9ucywgYWNjb3VudElkLCByZWNlaXZlcklkKSA9PiBhY3Rpb25zLm1hcCgoYSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBhLmVudW07XG4gICAgY29uc3QgeyBnYXMsIHB1YmxpY0tleSwgbWV0aG9kTmFtZSwgYXJncywgZGVwb3NpdCwgYWNjZXNzS2V5LCBjb2RlIH0gPSBhW3R5cGVdO1xuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgdHlwZTogdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSksXG4gICAgICAgIGdhczogKGdhcyAmJiBnYXMudG9TdHJpbmcoKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaWNfa2V5OiAocHVibGljS2V5ICYmIGNvbnZlcnRQS0ZvckNvbnRyYWN0KHB1YmxpY0tleSkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbWV0aG9kX25hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3M6IChhcmdzICYmIEJ1ZmZlci5mcm9tKGFyZ3MpLnRvU3RyaW5nKCdiYXNlNjQnKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiAoY29kZSAmJiBCdWZmZXIuZnJvbShjb2RlKS50b1N0cmluZygnYmFzZTY0JykpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYW1vdW50OiAoZGVwb3NpdCAmJiBkZXBvc2l0LnRvU3RyaW5nKCkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwb3NpdDogKGRlcG9zaXQgJiYgZGVwb3NpdC50b1N0cmluZygpKSB8fCAnMCcsXG4gICAgICAgIHBlcm1pc3Npb246IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChhY2Nlc3NLZXkpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVySWQgPT09IGFjY291bnRJZCAmJiBhY2Nlc3NLZXkucGVybWlzc2lvbi5lbnVtICE9PSAnZnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgIGFjdGlvbi5wZXJtaXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlOiBjb25zdGFudHNfMS5NVUxUSVNJR19BTExPV0FOQ0UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtZXRob2RfbmFtZXM6IGNvbnN0YW50c18xLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjZXNzS2V5LnBlcm1pc3Npb24uZW51bSA9PT0gJ2Z1bmN0aW9uQ2FsbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVjZWl2ZXJJZDogcmVjZWl2ZXJfaWQsIG1ldGhvZE5hbWVzOiBtZXRob2RfbmFtZXMsIGFsbG93YW5jZSB9ID0gYWNjZXNzS2V5LnBlcm1pc3Npb24uZnVuY3Rpb25DYWxsO1xuICAgICAgICAgICAgYWN0aW9uLnBlcm1pc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJfaWQsXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlOiAoYWxsb3dhbmNlICYmIGFsbG93YW5jZS50b1N0cmluZygpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb247XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/connection.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/connection.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = void 0;\nconst signers_1 = __webpack_require__(/*! @near-js/signers */ \"(ssr)/./node_modules/.pnpm/@near-js+signers@0.0.5/node_modules/@near-js/signers/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.0.7/node_modules/@near-js/providers/lib/index.js\");\n/**\n * @param config Contains connection info details\n * @returns {Provider}\n */\nfunction getProvider(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'JsonRpcProvider': return new providers_1.JsonRpcProvider(Object.assign({}, config.args));\n        default: throw new Error(`Unknown provider type ${config.type}`);\n    }\n}\n/**\n * @param config Contains connection info details\n * @returns {Signer}\n */\nfunction getSigner(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'InMemorySigner': {\n            return new signers_1.InMemorySigner(config.keyStore);\n        }\n        default: throw new Error(`Unknown signer type ${config.type}`);\n    }\n}\n/**\n * Connects an account to a given network via a given provider\n */\nclass Connection {\n    constructor(networkId, provider, signer, jsvmAccountId) {\n        this.networkId = networkId;\n        this.provider = provider;\n        this.signer = signer;\n        this.jsvmAccountId = jsvmAccountId;\n    }\n    /**\n     * @param config Contains connection info details\n     */\n    static fromConfig(config) {\n        const provider = getProvider(config.provider);\n        const signer = getSigner(config.signer);\n        return new Connection(config.networkId, provider, signer, config.jsvmAccountId);\n    }\n}\nexports.Connection = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyxzSEFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQW9CO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RiwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AwLjEuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2Nvbm5lY3Rpb24uanM/MDM5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHNpZ25lcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9zaWduZXJzXCIpO1xuY29uc3QgcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvcHJvdmlkZXJzXCIpO1xuLyoqXG4gKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gKiBAcmV0dXJucyB7UHJvdmlkZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKGNvbmZpZykge1xuICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICBjYXNlICdKc29uUnBjUHJvdmlkZXInOiByZXR1cm4gbmV3IHByb3ZpZGVyc18xLkpzb25ScGNQcm92aWRlcihPYmplY3QuYXNzaWduKHt9LCBjb25maWcuYXJncykpO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcHJvdmlkZXIgdHlwZSAke2NvbmZpZy50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIGNvbmZpZyBDb250YWlucyBjb25uZWN0aW9uIGluZm8gZGV0YWlsc1xuICogQHJldHVybnMge1NpZ25lcn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2lnbmVyKGNvbmZpZykge1xuICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICBjYXNlICdJbk1lbW9yeVNpZ25lcic6IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc2lnbmVyc18xLkluTWVtb3J5U2lnbmVyKGNvbmZpZy5rZXlTdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpZ25lciB0eXBlICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb25uZWN0cyBhbiBhY2NvdW50IHRvIGEgZ2l2ZW4gbmV0d29yayB2aWEgYSBnaXZlbiBwcm92aWRlclxuICovXG5jbGFzcyBDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIHByb3ZpZGVyLCBzaWduZXIsIGpzdm1BY2NvdW50SWQpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrSWQgPSBuZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgICAgIHRoaXMuanN2bUFjY291bnRJZCA9IGpzdm1BY2NvdW50SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29udGFpbnMgY29ubmVjdGlvbiBpbmZvIGRldGFpbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb25maWcucHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBzaWduZXIgPSBnZXRTaWduZXIoY29uZmlnLnNpZ25lcik7XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbihjb25maWcubmV0d29ya0lkLCBwcm92aWRlciwgc2lnbmVyLCBjb25maWcuanN2bUFjY291bnRJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.0.4/node_modules/@near-js/utils/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default((0, utils_1.parseNearAmount)('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEI7QUFDaEwsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUI7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDAuMS40L25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29uc3RhbnRzLmpzPzRlODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUyA9IGV4cG9ydHMuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0RFUE9TSVQgPSBleHBvcnRzLk1VTFRJU0lHX0dBUyA9IGV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5leHBvcnRzLk1VTFRJU0lHX1NUT1JBR0VfS0VZID0gJ19fbXVsdGlzaWdSZXF1ZXN0JztcbmV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgoMCwgdXRpbHNfMS5wYXJzZU5lYXJBbW91bnQpKCcxJykpO1xuLy8gVE9ETzogRGlmZmVyZW50IGdhcyB2YWx1ZSBmb3IgZGlmZmVyZW50IHJlcXVlc3RzIChjYW4gcmVkdWNlIGdhcyB1c2FnZSBkcmFtYXRpY2FsbHkpXG5leHBvcnRzLk1VTFRJU0lHX0dBUyA9IG5ldyBibl9qc18xLmRlZmF1bHQoJzEwMDAwMDAwMDAwMDAwMCcpO1xuZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnMCcpO1xuZXhwb3J0cy5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUyA9IFsnYWRkX3JlcXVlc3QnLCAnYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0nLCAnZGVsZXRlX3JlcXVlc3QnLCAnY29uZmlybSddO1xuZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMgPSBbJ2NvbmZpcm0nXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/contract.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/contract.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.0.4/node_modules/@near-js/utils/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst ajv_1 = __importDefault(__webpack_require__(/*! ajv */ \"(ssr)/./node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/ajv.js\"));\nconst ajv_formats_1 = __importDefault(__webpack_require__(/*! ajv-formats */ \"(ssr)/./node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.12.0/node_modules/ajv-formats/dist/index.js\"));\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js\"));\nconst near_abi_1 = __webpack_require__(/*! near-abi */ \"(ssr)/./node_modules/.pnpm/near-abi@0.1.1/node_modules/near-abi/lib/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/errors.js\");\n// Makes `function.name` return given name\nfunction nameFunction(name, body) {\n    return {\n        [name](...args) {\n            return body(...args);\n        }\n    }[name];\n}\nfunction validateArguments(args, abiFunction, ajv, abiRoot) {\n    var _a;\n    if (!isObject(args))\n        return;\n    if (abiFunction.params && abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);\n    }\n    if (abiFunction.result && abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);\n    }\n    const params = ((_a = abiFunction.params) === null || _a === void 0 ? void 0 : _a.args) || [];\n    for (const p of params) {\n        const arg = args[p.name];\n        const typeSchema = p.type_schema;\n        typeSchema.definitions = abiRoot.body.root_schema.definitions;\n        const validate = ajv.compile(typeSchema);\n        if (!validate(arg)) {\n            throw new errors_1.ArgumentSchemaError(p.name, validate.errors);\n        }\n    }\n    // Check there are no extra unknown arguments passed\n    for (const argName of Object.keys(args)) {\n        const param = params.find((p) => p.name === argName);\n        if (!param) {\n            throw new errors_1.UnknownArgumentError(argName, params.map((p) => p.name));\n        }\n    }\n}\nfunction createAjv() {\n    // Strict mode is disabled for now as it complains about unknown formats. We need to\n    // figure out if we want to support a fixed set of formats. `uint32` and `uint64`\n    // are added explicitly just to reduce the amount of warnings as these are very popular\n    // types.\n    const ajv = new ajv_1.default({\n        strictSchema: false,\n        formats: {\n            uint32: true,\n            uint64: true\n        }\n    });\n    (0, ajv_formats_1.default)(ajv);\n    return ajv;\n}\nconst isUint8Array = (x) => x && x.byteLength !== undefined && x.byteLength === x.length;\nconst isObject = (x) => Object.prototype.toString.call(x) === '[object Object]';\n/**\n * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#contract](https://docs.near.org/tools/near-api-js/quick-reference#contract)\n * @example\n * ```js\n * import { Contract } from 'near-api-js';\n *\n * async function contractExample() {\n *   const methodOptions = {\n *     viewMethods: ['getMessageByAccountId'],\n *     changeMethods: ['addMessage']\n *   };\n *   const contract = new Contract(\n *     wallet.account(),\n *     'contract-id.testnet',\n *     methodOptions\n *   );\n *\n *   // use a contract view method\n *   const messages = await contract.getMessages({\n *     accountId: 'example-account.testnet'\n *   });\n *\n *   // use a contract change method\n *   await contract.addMessage({\n *      meta: 'some info',\n *      callbackUrl: 'https://example.com/callback',\n *      args: { text: 'my message' },\n *      amount: 1\n *   })\n * }\n * ```\n */\nclass Contract {\n    /**\n     * @param account NEAR account to sign change method transactions\n     * @param contractId NEAR account id where the contract is deployed\n     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`\n     */\n    constructor(account, contractId, options) {\n        this.account = account;\n        this.contractId = contractId;\n        const { viewMethods = [], changeMethods = [], abi: abiRoot } = options;\n        let viewMethodsWithAbi = viewMethods.map((name) => ({ name, abi: null }));\n        let changeMethodsWithAbi = changeMethods.map((name) => ({ name, abi: null }));\n        if (abiRoot) {\n            if (viewMethodsWithAbi.length > 0 || changeMethodsWithAbi.length > 0) {\n                throw new errors_1.ConflictingOptions();\n            }\n            viewMethodsWithAbi = abiRoot.body.functions\n                .filter((m) => m.kind === near_abi_1.AbiFunctionKind.View)\n                .map((m) => ({ name: m.name, abi: m }));\n            changeMethodsWithAbi = abiRoot.body.functions\n                .filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call)\n                .map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));\n        }\n        const ajv = createAjv();\n        viewMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, (args = {}, options = {}, ...ignored) => __awaiter(this, void 0, void 0, function* () {\n                    if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options)) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (abi) {\n                        validateArguments(args, abi, ajv, abiRoot);\n                    }\n                    return this.account.viewFunction(Object.assign({ contractId: this.contractId, methodName: name, args }, options));\n                }))\n            });\n        });\n        changeMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, (...args) => __awaiter(this, void 0, void 0, function* () {\n                    if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (args.length > 1 || !(args[0] && args[0].args)) {\n                        const deprecate = (0, depd_1.default)('contract.methodName(args, gas, amount)');\n                        deprecate('use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead');\n                        args[0] = {\n                            args: args[0],\n                            gas: args[1],\n                            amount: args[2]\n                        };\n                    }\n                    if (abi) {\n                        validateArguments(args[0].args, abi, ajv, abiRoot);\n                    }\n                    return this._changeMethod(Object.assign({ methodName: name }, args[0]));\n                }))\n            });\n        });\n    }\n    _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            validateBNLike({ gas, amount });\n            const rawResult = yield this.account.functionCall({\n                contractId: this.contractId,\n                methodName,\n                args,\n                gas,\n                attachedDeposit: amount,\n                walletMeta: meta,\n                walletCallbackUrl: callbackUrl\n            });\n            return (0, utils_1.getTransactionLastResult)(rawResult);\n        });\n    }\n}\nexports.Contract = Contract;\n/**\n * Validation on arguments being a big number from bn.js\n * Throws if an argument is not in BN format or otherwise invalid\n * @param argMap\n */\nfunction validateBNLike(argMap) {\n    const bnLike = 'number, decimal string or BN';\n    for (const argName of Object.keys(argMap)) {\n        const argValue = argMap[argName];\n        if (argValue && !bn_js_1.default.isBN(argValue) && isNaN(argValue)) {\n            throw new types_1.ArgumentTypeError(argName, bnLike, argValue);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4Qyw4QkFBOEIsbUJBQU8sQ0FBQywrRUFBSztBQUMzQyxzQ0FBc0MsbUJBQU8sQ0FBQyxtSEFBYTtBQUMzRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxrRkFBTztBQUMvQywrQkFBK0IsbUJBQU8sQ0FBQyw4RUFBTTtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBVTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxpSEFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRSw4REFBOEQsaUJBQWlCO0FBQy9FLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFzQztBQUM3RTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFEQUFxRDtBQUMxSCxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMENBQTBDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEYsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDAuMS40L25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29udHJhY3QuanM/YTdlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3R5cGVzXCIpO1xuY29uc3QgYWp2XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFqdlwiKSk7XG5jb25zdCBhanZfZm9ybWF0c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKSk7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBkZXBkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlcGRcIikpO1xuY29uc3QgbmVhcl9hYmlfMSA9IHJlcXVpcmUoXCJuZWFyLWFiaVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLy8gTWFrZXMgYGZ1bmN0aW9uLm5hbWVgIHJldHVybiBnaXZlbiBuYW1lXG5mdW5jdGlvbiBuYW1lRnVuY3Rpb24obmFtZSwgYm9keSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtuYW1lXSguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1bbmFtZV07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFyZ3VtZW50cyhhcmdzLCBhYmlGdW5jdGlvbiwgYWp2LCBhYmlSb290KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghaXNPYmplY3QoYXJncykpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoYWJpRnVuY3Rpb24ucGFyYW1zICYmIGFiaUZ1bmN0aW9uLnBhcmFtcy5zZXJpYWxpemF0aW9uX3R5cGUgIT09IG5lYXJfYWJpXzEuQWJpU2VyaWFsaXphdGlvblR5cGUuSnNvbikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IoYWJpRnVuY3Rpb24ubmFtZSwgYWJpRnVuY3Rpb24ucGFyYW1zLnNlcmlhbGl6YXRpb25fdHlwZSk7XG4gICAgfVxuICAgIGlmIChhYmlGdW5jdGlvbi5yZXN1bHQgJiYgYWJpRnVuY3Rpb24ucmVzdWx0LnNlcmlhbGl6YXRpb25fdHlwZSAhPT0gbmVhcl9hYmlfMS5BYmlTZXJpYWxpemF0aW9uVHlwZS5Kc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcihhYmlGdW5jdGlvbi5uYW1lLCBhYmlGdW5jdGlvbi5yZXN1bHQuc2VyaWFsaXphdGlvbl90eXBlKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gKChfYSA9IGFiaUZ1bmN0aW9uLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFyZ3MpIHx8IFtdO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYXJnID0gYXJnc1twLm5hbWVdO1xuICAgICAgICBjb25zdCB0eXBlU2NoZW1hID0gcC50eXBlX3NjaGVtYTtcbiAgICAgICAgdHlwZVNjaGVtYS5kZWZpbml0aW9ucyA9IGFiaVJvb3QuYm9keS5yb290X3NjaGVtYS5kZWZpbml0aW9ucztcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBhanYuY29tcGlsZSh0eXBlU2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRTY2hlbWFFcnJvcihwLm5hbWUsIHZhbGlkYXRlLmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhlcmUgYXJlIG5vIGV4dHJhIHVua25vd24gYXJndW1lbnRzIHBhc3NlZFxuICAgIGZvciAoY29uc3QgYXJnTmFtZSBvZiBPYmplY3Qua2V5cyhhcmdzKSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IHBhcmFtcy5maW5kKChwKSA9PiBwLm5hbWUgPT09IGFyZ05hbWUpO1xuICAgICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5rbm93bkFyZ3VtZW50RXJyb3IoYXJnTmFtZSwgcGFyYW1zLm1hcCgocCkgPT4gcC5uYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBanYoKSB7XG4gICAgLy8gU3RyaWN0IG1vZGUgaXMgZGlzYWJsZWQgZm9yIG5vdyBhcyBpdCBjb21wbGFpbnMgYWJvdXQgdW5rbm93biBmb3JtYXRzLiBXZSBuZWVkIHRvXG4gICAgLy8gZmlndXJlIG91dCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgYSBmaXhlZCBzZXQgb2YgZm9ybWF0cy4gYHVpbnQzMmAgYW5kIGB1aW50NjRgXG4gICAgLy8gYXJlIGFkZGVkIGV4cGxpY2l0bHkganVzdCB0byByZWR1Y2UgdGhlIGFtb3VudCBvZiB3YXJuaW5ncyBhcyB0aGVzZSBhcmUgdmVyeSBwb3B1bGFyXG4gICAgLy8gdHlwZXMuXG4gICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICBzdHJpY3RTY2hlbWE6IGZhbHNlLFxuICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICB1aW50MzI6IHRydWUsXG4gICAgICAgICAgICB1aW50NjQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgICgwLCBhanZfZm9ybWF0c18xLmRlZmF1bHQpKGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn1cbmNvbnN0IGlzVWludDhBcnJheSA9ICh4KSA9PiB4ICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHguYnl0ZUxlbmd0aCA9PT0geC5sZW5ndGg7XG5jb25zdCBpc09iamVjdCA9ICh4KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuLyoqXG4gKiBEZWZpbmVzIGEgc21hcnQgY29udHJhY3Qgb24gTkVBUiBpbmNsdWRpbmcgdGhlIGNoYW5nZSAobXV0YWJsZSkgYW5kIHZpZXcgKG5vbi1tdXRhYmxlKSBtZXRob2RzXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNjb250cmFjdF0oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNjb250cmFjdClcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tICduZWFyLWFwaS1qcyc7XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gY29udHJhY3RFeGFtcGxlKCkge1xuICogICBjb25zdCBtZXRob2RPcHRpb25zID0ge1xuICogICAgIHZpZXdNZXRob2RzOiBbJ2dldE1lc3NhZ2VCeUFjY291bnRJZCddLFxuICogICAgIGNoYW5nZU1ldGhvZHM6IFsnYWRkTWVzc2FnZSddXG4gKiAgIH07XG4gKiAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFxuICogICAgIHdhbGxldC5hY2NvdW50KCksXG4gKiAgICAgJ2NvbnRyYWN0LWlkLnRlc3RuZXQnLFxuICogICAgIG1ldGhvZE9wdGlvbnNcbiAqICAgKTtcbiAqXG4gKiAgIC8vIHVzZSBhIGNvbnRyYWN0IHZpZXcgbWV0aG9kXG4gKiAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgY29udHJhY3QuZ2V0TWVzc2FnZXMoe1xuICogICAgIGFjY291bnRJZDogJ2V4YW1wbGUtYWNjb3VudC50ZXN0bmV0J1xuICogICB9KTtcbiAqXG4gKiAgIC8vIHVzZSBhIGNvbnRyYWN0IGNoYW5nZSBtZXRob2RcbiAqICAgYXdhaXQgY29udHJhY3QuYWRkTWVzc2FnZSh7XG4gKiAgICAgIG1ldGE6ICdzb21lIGluZm8nLFxuICogICAgICBjYWxsYmFja1VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vY2FsbGJhY2snLFxuICogICAgICBhcmdzOiB7IHRleHQ6ICdteSBtZXNzYWdlJyB9LFxuICogICAgICBhbW91bnQ6IDFcbiAqICAgfSlcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjY291bnQgTkVBUiBhY2NvdW50IHRvIHNpZ24gY2hhbmdlIG1ldGhvZCB0cmFuc2FjdGlvbnNcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJZCBORUFSIGFjY291bnQgaWQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgTkVBUiBzbWFydCBjb250cmFjdCBtZXRob2RzIHRoYXQgeW91ciBhcHBsaWNhdGlvbiB3aWxsIHVzZS4gVGhlc2Ugd2lsbCBiZSBhdmFpbGFibGUgYXMgYGNvbnRyYWN0Lm1ldGhvZE5hbWVgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWNjb3VudCwgY29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgICAgICB0aGlzLmNvbnRyYWN0SWQgPSBjb250cmFjdElkO1xuICAgICAgICBjb25zdCB7IHZpZXdNZXRob2RzID0gW10sIGNoYW5nZU1ldGhvZHMgPSBbXSwgYWJpOiBhYmlSb290IH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgdmlld01ldGhvZHNXaXRoQWJpID0gdmlld01ldGhvZHMubWFwKChuYW1lKSA9PiAoeyBuYW1lLCBhYmk6IG51bGwgfSkpO1xuICAgICAgICBsZXQgY2hhbmdlTWV0aG9kc1dpdGhBYmkgPSBjaGFuZ2VNZXRob2RzLm1hcCgobmFtZSkgPT4gKHsgbmFtZSwgYWJpOiBudWxsIH0pKTtcbiAgICAgICAgaWYgKGFiaVJvb3QpIHtcbiAgICAgICAgICAgIGlmICh2aWV3TWV0aG9kc1dpdGhBYmkubGVuZ3RoID4gMCB8fCBjaGFuZ2VNZXRob2RzV2l0aEFiaS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbmZsaWN0aW5nT3B0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlld01ldGhvZHNXaXRoQWJpID0gYWJpUm9vdC5ib2R5LmZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG0pID0+IG0ua2luZCA9PT0gbmVhcl9hYmlfMS5BYmlGdW5jdGlvbktpbmQuVmlldylcbiAgICAgICAgICAgICAgICAubWFwKChtKSA9PiAoeyBuYW1lOiBtLm5hbWUsIGFiaTogbSB9KSk7XG4gICAgICAgICAgICBjaGFuZ2VNZXRob2RzV2l0aEFiaSA9IGFiaVJvb3QuYm9keS5mdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChtZXRob2RBYmkpID0+IG1ldGhvZEFiaS5raW5kID09PSBuZWFyX2FiaV8xLkFiaUZ1bmN0aW9uS2luZC5DYWxsKVxuICAgICAgICAgICAgICAgIC5tYXAoKG1ldGhvZEFiaSkgPT4gKHsgbmFtZTogbWV0aG9kQWJpLm5hbWUsIGFiaTogbWV0aG9kQWJpIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhanYgPSBjcmVhdGVBanYoKTtcbiAgICAgICAgdmlld01ldGhvZHNXaXRoQWJpLmZvckVhY2goKHsgbmFtZSwgYWJpIH0pID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVGdW5jdGlvbihuYW1lLCAoYXJncyA9IHt9LCBvcHRpb25zID0ge30sIC4uLmlnbm9yZWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQubGVuZ3RoIHx8ICEoaXNPYmplY3QoYXJncykgfHwgaXNVaW50OEFycmF5KGFyZ3MpKSB8fCAhaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlBvc2l0aW9uYWxBcmdzRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50cyhhcmdzLCBhYmksIGFqdiwgYWJpUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudC52aWV3RnVuY3Rpb24oT2JqZWN0LmFzc2lnbih7IGNvbnRyYWN0SWQ6IHRoaXMuY29udHJhY3RJZCwgbWV0aG9kTmFtZTogbmFtZSwgYXJncyB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5nZU1ldGhvZHNXaXRoQWJpLmZvckVhY2goKHsgbmFtZSwgYWJpIH0pID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVGdW5jdGlvbihuYW1lLCAoLi4uYXJncykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggJiYgKGFyZ3MubGVuZ3RoID4gMyB8fCAhKGlzT2JqZWN0KGFyZ3NbMF0pIHx8IGlzVWludDhBcnJheShhcmdzWzBdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5Qb3NpdGlvbmFsQXJnc0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSB8fCAhKGFyZ3NbMF0gJiYgYXJnc1swXS5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRlID0gKDAsIGRlcGRfMS5kZWZhdWx0KSgnY29udHJhY3QubWV0aG9kTmFtZShhcmdzLCBnYXMsIGFtb3VudCknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZSgndXNlIGBjb250cmFjdC5tZXRob2ROYW1lKHsgYXJncywgZ2FzPywgYW1vdW50PywgY2FsbGJhY2tVcmw/LCBtZXRhPyB9KWAgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhczogYXJnc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IGFyZ3NbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFiaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBcmd1bWVudHMoYXJnc1swXS5hcmdzLCBhYmksIGFqdiwgYWJpUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZU1ldGhvZChPYmplY3QuYXNzaWduKHsgbWV0aG9kTmFtZTogbmFtZSB9LCBhcmdzWzBdKSk7XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jaGFuZ2VNZXRob2QoeyBhcmdzLCBtZXRob2ROYW1lLCBnYXMsIGFtb3VudCwgbWV0YSwgY2FsbGJhY2tVcmwgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFsaWRhdGVCTkxpa2UoeyBnYXMsIGFtb3VudCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IHlpZWxkIHRoaXMuYWNjb3VudC5mdW5jdGlvbkNhbGwoe1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHRoaXMuY29udHJhY3RJZCxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIGF0dGFjaGVkRGVwb3NpdDogYW1vdW50LFxuICAgICAgICAgICAgICAgIHdhbGxldE1ldGE6IG1ldGEsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2FsbGJhY2tVcmw6IGNhbGxiYWNrVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5nZXRUcmFuc2FjdGlvbkxhc3RSZXN1bHQpKHJhd1Jlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcbi8qKlxuICogVmFsaWRhdGlvbiBvbiBhcmd1bWVudHMgYmVpbmcgYSBiaWcgbnVtYmVyIGZyb20gYm4uanNcbiAqIFRocm93cyBpZiBhbiBhcmd1bWVudCBpcyBub3QgaW4gQk4gZm9ybWF0IG9yIG90aGVyd2lzZSBpbnZhbGlkXG4gKiBAcGFyYW0gYXJnTWFwXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQk5MaWtlKGFyZ01hcCkge1xuICAgIGNvbnN0IGJuTGlrZSA9ICdudW1iZXIsIGRlY2ltYWwgc3RyaW5nIG9yIEJOJztcbiAgICBmb3IgKGNvbnN0IGFyZ05hbWUgb2YgT2JqZWN0LmtleXMoYXJnTWFwKSkge1xuICAgICAgICBjb25zdCBhcmdWYWx1ZSA9IGFyZ01hcFthcmdOYW1lXTtcbiAgICAgICAgaWYgKGFyZ1ZhbHVlICYmICFibl9qc18xLmRlZmF1bHQuaXNCTihhcmdWYWx1ZSkgJiYgaXNOYU4oYXJnVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5Bcmd1bWVudFR5cGVFcnJvcihhcmdOYW1lLCBibkxpa2UsIGFyZ1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/errors.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/errors.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConflictingOptions = exports.ArgumentSchemaError = exports.UnknownArgumentError = exports.UnsupportedSerializationError = void 0;\nclass UnsupportedSerializationError extends Error {\n    constructor(methodName, serializationType) {\n        super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);\n    }\n}\nexports.UnsupportedSerializationError = UnsupportedSerializationError;\nclass UnknownArgumentError extends Error {\n    constructor(actualArgName, expectedArgNames) {\n        super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);\n    }\n}\nexports.UnknownArgumentError = UnknownArgumentError;\nclass ArgumentSchemaError extends Error {\n    constructor(argName, errors) {\n        super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors)}'`);\n    }\n}\nexports.ArgumentSchemaError = ArgumentSchemaError;\nclass ConflictingOptions extends Error {\n    constructor() {\n        super('Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.');\n    }\n}\nexports.ConflictingOptions = ConflictingOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcscUNBQXFDO0FBQy9IO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVywrQ0FBK0Msa0JBQWtCO0FBQzlHO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxjQUFjLGVBQWUsaUNBQWlDO0FBQ3RHO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDJCQUEyQixRQUFRLG1EQUFtRCx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AwLjEuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2Vycm9ycy5qcz82MTA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25mbGljdGluZ09wdGlvbnMgPSBleHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBleHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIFVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIHNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIHN1cGVyKGBDb250cmFjdCBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGlzIHVzaW5nIGFuIHVuc3VwcG9ydGVkIHNlcmlhbGl6YXRpb24gdHlwZSAke3NlcmlhbGl6YXRpb25UeXBlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjtcbmNsYXNzIFVua25vd25Bcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFjdHVhbEFyZ05hbWUsIGV4cGVjdGVkQXJnTmFtZXMpIHtcbiAgICAgICAgc3VwZXIoYFVucmVjb2duaXplZCBhcmd1bWVudCAnJHthY3R1YWxBcmdOYW1lfScsIGV4cGVjdGVkICcke0pTT04uc3RyaW5naWZ5KGV4cGVjdGVkQXJnTmFtZXMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gVW5rbm93bkFyZ3VtZW50RXJyb3I7XG5jbGFzcyBBcmd1bWVudFNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZ05hbWUsIGVycm9ycykge1xuICAgICAgICBzdXBlcihgQXJndW1lbnQgJyR7YXJnTmFtZX0nIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHNwZWNpZmllZCBBQkkgc2NoZW1hOiAnJHtKU09OLnN0cmluZ2lmeShlcnJvcnMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBBcmd1bWVudFNjaGVtYUVycm9yO1xuY2xhc3MgQ29uZmxpY3RpbmdPcHRpb25zIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ29uZmxpY3RpbmcgY29udHJhY3QgbWV0aG9kIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZC4gWW91IGNhbiBlaXRoZXIgc3BlY2lmeSBBQkkgb3IgYSBsaXN0IG9mIHZpZXcvY2FsbCBtZXRob2RzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmxpY3RpbmdPcHRpb25zID0gQ29uZmxpY3RpbmdPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.UnsupportedSerializationError = exports.UnknownArgumentError = exports.ConflictingOptions = exports.ArgumentSchemaError = exports.Contract = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.Connection = exports.AccountMultisig = exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = exports.Account2FA = exports.Account = void 0;\nvar account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account.js\");\nObject.defineProperty(exports, \"Account\", ({ enumerable: true, get: function () { return account_1.Account; } }));\nvar account_2fa_1 = __webpack_require__(/*! ./account_2fa */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_2fa.js\");\nObject.defineProperty(exports, \"Account2FA\", ({ enumerable: true, get: function () { return account_2fa_1.Account2FA; } }));\nvar account_creator_1 = __webpack_require__(/*! ./account_creator */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_creator.js\");\nObject.defineProperty(exports, \"AccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.AccountCreator; } }));\nObject.defineProperty(exports, \"LocalAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.LocalAccountCreator; } }));\nObject.defineProperty(exports, \"UrlAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.UrlAccountCreator; } }));\nvar account_multisig_1 = __webpack_require__(/*! ./account_multisig */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/account_multisig.js\");\nObject.defineProperty(exports, \"AccountMultisig\", ({ enumerable: true, get: function () { return account_multisig_1.AccountMultisig; } }));\nvar connection_1 = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/connection.js\");\nObject.defineProperty(exports, \"Connection\", ({ enumerable: true, get: function () { return connection_1.Connection; } }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/constants.js\");\nObject.defineProperty(exports, \"MULTISIG_STORAGE_KEY\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_STORAGE_KEY; } }));\nObject.defineProperty(exports, \"MULTISIG_ALLOWANCE\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_ALLOWANCE; } }));\nObject.defineProperty(exports, \"MULTISIG_GAS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_GAS; } }));\nObject.defineProperty(exports, \"MULTISIG_DEPOSIT\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_DEPOSIT; } }));\nObject.defineProperty(exports, \"MULTISIG_CHANGE_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CHANGE_METHODS; } }));\nObject.defineProperty(exports, \"MULTISIG_CONFIRM_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CONFIRM_METHODS; } }));\nvar contract_1 = __webpack_require__(/*! ./contract */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/contract.js\");\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_1.Contract; } }));\nvar errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/errors.js\");\nObject.defineProperty(exports, \"ArgumentSchemaError\", ({ enumerable: true, get: function () { return errors_1.ArgumentSchemaError; } }));\nObject.defineProperty(exports, \"ConflictingOptions\", ({ enumerable: true, get: function () { return errors_1.ConflictingOptions; } }));\nObject.defineProperty(exports, \"UnknownArgumentError\", ({ enumerable: true, get: function () { return errors_1.UnknownArgumentError; } }));\nObject.defineProperty(exports, \"UnsupportedSerializationError\", ({ enumerable: true, get: function () { return errors_1.UnsupportedSerializationError; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js\");\nObject.defineProperty(exports, \"MultisigDeleteRequestRejectionError\", ({ enumerable: true, get: function () { return types_1.MultisigDeleteRequestRejectionError; } }));\nObject.defineProperty(exports, \"MultisigStateStatus\", ({ enumerable: true, get: function () { return types_1.MultisigStateStatus; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQ0FBMkMsR0FBRyxxQ0FBcUMsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyxnQ0FBZ0MsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxlQUFlO0FBQzFqQixnQkFBZ0IsbUJBQU8sQ0FBQyxtSEFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csb0JBQW9CLG1CQUFPLENBQUMsMkhBQWU7QUFDM0MsOENBQTZDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3pILHdCQUF3QixtQkFBTyxDQUFDLG1JQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksdURBQXNELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQy9JLHFEQUFvRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMzSSx5QkFBeUIsbUJBQU8sQ0FBQyxxSUFBb0I7QUFDckQsbURBQWtELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLHlIQUFjO0FBQ3pDLDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxrQkFBa0IsbUJBQU8sQ0FBQyx1SEFBYTtBQUN2Qyx3REFBdUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDM0ksc0RBQXFELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3ZJLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksMkRBQTBELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ2pKLDREQUEyRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUNuSixpQkFBaUIsbUJBQU8sQ0FBQyxxSEFBWTtBQUNyQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsZUFBZSxtQkFBTyxDQUFDLGlIQUFVO0FBQ2pDLHVEQUFzRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN0SSxzREFBcUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDcEksd0RBQXVELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3hJLGlFQUFnRSxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUMxSixjQUFjLG1CQUFPLENBQUMsK0dBQVM7QUFDL0IsdUVBQXNFLEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3JLLHVEQUFzRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9pbmRleC5qcz8zN2JlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzID0gZXhwb3J0cy5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IgPSBleHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5Db25mbGljdGluZ09wdGlvbnMgPSBleHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTID0gZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUID0gZXhwb3J0cy5NVUxUSVNJR19HQVMgPSBleHBvcnRzLk1VTFRJU0lHX0FMTE9XQU5DRSA9IGV4cG9ydHMuTVVMVElTSUdfU1RPUkFHRV9LRVkgPSBleHBvcnRzLkNvbm5lY3Rpb24gPSBleHBvcnRzLkFjY291bnRNdWx0aXNpZyA9IGV4cG9ydHMuVXJsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5BY2NvdW50MkZBID0gZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xudmFyIGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzEuQWNjb3VudDsgfSB9KTtcbnZhciBhY2NvdW50XzJmYV8xID0gcmVxdWlyZShcIi4vYWNjb3VudF8yZmFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50MkZBXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzJmYV8xLkFjY291bnQyRkE7IH0gfSk7XG52YXIgYWNjb3VudF9jcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50X2NyZWF0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50Q3JlYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjb3VudF9jcmVhdG9yXzEuQWNjb3VudENyZWF0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2NhbEFjY291bnRDcmVhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50X2NyZWF0b3JfMS5Mb2NhbEFjY291bnRDcmVhdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXJsQWNjb3VudENyZWF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfY3JlYXRvcl8xLlVybEFjY291bnRDcmVhdG9yOyB9IH0pO1xudmFyIGFjY291bnRfbXVsdGlzaWdfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRfbXVsdGlzaWdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50TXVsdGlzaWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfbXVsdGlzaWdfMS5BY2NvdW50TXVsdGlzaWc7IH0gfSk7XG52YXIgY29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4vY29ubmVjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uOyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfU1RPUkFHRV9LRVlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfQUxMT1dBTkNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19BTExPV0FOQ0U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19HQVNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1VTFRJU0lHX0RFUE9TSVRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19DSEFOR0VfTUVUSE9EU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19DT05GSVJNX01FVEhPRFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUzsgfSB9KTtcbnZhciBjb250cmFjdF8xID0gcmVxdWlyZShcIi4vY29udHJhY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfMS5Db250cmFjdDsgfSB9KTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyZ3VtZW50U2NoZW1hRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkFyZ3VtZW50U2NoZW1hRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25mbGljdGluZ09wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkNvbmZsaWN0aW5nT3B0aW9uczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVua25vd25Bcmd1bWVudEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5Vbmtub3duQXJndW1lbnRFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpc2lnU3RhdGVTdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1czsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = void 0;\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQ0FBMkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdGQUF3RiwyQ0FBMkMsS0FBSztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RCwyQkFBMkIsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMC4xLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi90eXBlcy5qcz8yYmJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzID0gZXhwb3J0cy5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IHZvaWQgMDtcbnZhciBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcjtcbihmdW5jdGlvbiAoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IpIHtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIkNBTk5PVF9ERVNFUklBTElaRV9TVEFURVwiXSA9IFwiQ2Fubm90IGRlc2VyaWFsaXplIHRoZSBjb250cmFjdCBzdGF0ZVwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTVVMVElTSUdfTk9UX0lOSVRJQUxJWkVEXCJdID0gXCJTbWFydCBjb250cmFjdCBwYW5pY2tlZDogTXVsdGlzaWcgY29udHJhY3Qgc2hvdWxkIGJlIGluaXRpYWxpemVkIGJlZm9yZSB1c2FnZVwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTk9fU1VDSF9SRVFVRVNUXCJdID0gXCJTbWFydCBjb250cmFjdCBwYW5pY2tlZDogcGFuaWNrZWQgYXQgJ05vIHN1Y2ggcmVxdWVzdDogZWl0aGVyIHdyb25nIG51bWJlciBvciBhbHJlYWR5IGNvbmZpcm1lZCdcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIlJFUVVFU1RfQ09PTERPV05fRVJST1JcIl0gPSBcIlJlcXVlc3QgY2Fubm90IGJlIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY3JlYXRpb24uXCI7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJNRVRIT0RfTk9UX0ZPVU5EXCJdID0gXCJDb250cmFjdCBtZXRob2QgaXMgbm90IGZvdW5kXCI7XG59KShNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgfHwgKGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSB7fSkpO1xudmFyIE11bHRpc2lnU3RhdGVTdGF0dXM7XG4oZnVuY3Rpb24gKE11bHRpc2lnU3RhdGVTdGF0dXMpIHtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJJTlZBTElEX1NUQVRFXCJdID0gMF0gPSBcIklOVkFMSURfU1RBVEVcIjtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJTVEFURV9OT1RfSU5JVElBTElaRURcIl0gPSAxXSA9IFwiU1RBVEVfTk9UX0lOSVRJQUxJWkVEXCI7XG4gICAgTXVsdGlzaWdTdGF0ZVN0YXR1c1tNdWx0aXNpZ1N0YXRlU3RhdHVzW1wiVkFMSURfU1RBVEVcIl0gPSAyXSA9IFwiVkFMSURfU1RBVEVcIjtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJVTktOT1dOX1NUQVRFXCJdID0gM10gPSBcIlVOS05PV05fU1RBVEVcIjtcbn0pKE11bHRpc2lnU3RhdGVTdGF0dXMgPSBleHBvcnRzLk11bHRpc2lnU3RhdGVTdGF0dXMgfHwgKGV4cG9ydHMuTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@0.1.4/node_modules/@near-js/accounts/lib/types.js\n");

/***/ })

};
;